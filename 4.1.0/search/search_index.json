{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to gradle use-python plugin","text":"<p>Use python in gradle build. The only plugin intention is to simplify python usage from gradle (without managing python itself).</p> <p>Release notes - Compatibility - License</p> <p>Who's using</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Works with directly installed python or docker container (with python)</li> <li>Creates local (project-specific) virtualenv (project-specific python copy)</li> <li>Installs required pip modules (venv by default, but could be global installation)</li> <li>Support requirements.txt file (limited by default)</li> <li>Gradle configuration cache supported </li> <li>Could be used as basement for building plugins for specific python modules (like   mkdocs plugin)  </li> </ul>"},{"location":"getting-started/","title":"Getting started","text":"<p>Note</p> <p>Plugin does not install python and pip itself and use globally installed python (by default). It's easier to prepare python manually because python have good compatibility (from user perspective) and does not need to be updated often.</p>"},{"location":"getting-started/#installation","title":"installation","text":"<pre><code>buildscript {\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath 'ru.vyarus:gradle-use-python-plugin:4.1.0'\n    }\n}\napply plugin: 'ru.vyarus.use-python'\n</code></pre> <p>OR</p> <pre><code>plugins {\n    id 'ru.vyarus.use-python' version '4.1.0'\n}\n</code></pre> <p>Compatibility matrix</p>"},{"location":"getting-started/#python-pip","title":"Python &amp; Pip","text":"<p>Make sure python and pip are installed:</p> <pre><code>python --version  \npip --version\n</code></pre> <p>On *nix <code>python</code> usually reference python2. For python3:</p> <pre><code>python3 --version  \npip3 --version\n</code></pre> <p>Install python if required.</p>"},{"location":"getting-started/#docker","title":"Docker","text":"<p>If you have docker installed, you can use python from docker container:</p> <pre><code>python.docker.use = true\n</code></pre> <p>In this case, global python installation is not required.</p>"},{"location":"getting-started/#pip-modules","title":"Pip modules","text":"<p>If additional pip modules required configure them:</p> <pre><code>python.pip 'module1:1.0', 'module2:1.0'\n</code></pre> <p>or</p> <pre><code>python {\n    pip 'module1:1.0'\n    pip 'module2:1.0'\n}\n</code></pre> <p>Important</p> <p>Version ranges are not allowed for reproducible builds! (but, eventually, there would be problems in any case because of transitive dependencies)   </p> <p>Module features and VCS modules supported.</p>"},{"location":"getting-started/#behaviour","title":"Behaviour","text":"<p>Default behaviour:</p> <ul> <li>if venv or <code>virtualenv</code> module installed (virtualenv could be installed automatically):   manage pip dependencies per project (env <code>.gradle/python</code> created)</li> <li>if no virtualenv - use user scope (<code>--user</code> pip flag):   pip modules are installed only for current user (this avoid permission problems on linux)</li> </ul> <p>Tip</p> <p>Venv used by default because it is bundled with python since python 3.3. On linux distibutions, venv might be installed as a separate package (python3-venv), but, usually, it also installed by default. When venv is not found, plugin would try to fall back to virtualenv. </p> <p>Note</p> <p>It is not a problem if your project environment was created with virtualenv and now, by default, venv would be used. Existing environment is used directly - venv/virtualev used only for environment creation.</p> <p>To change defaults:</p> <pre><code>python.scope = VIRTUALENV\n</code></pre> <ul> <li><code>GLOBAL</code> - install modules globally (this may not work on linux due to permissions)</li> <li><code>USER</code> - use <code>--user</code> flag to install for current user only</li> <li><code>VIRTUALENV_OR_USER</code> - default</li> <li><code>VIRTUALENV</code> - use <code>venv</code> / <code>virtualenv</code> (if module not installed - error thrown)</li> </ul> <p>Note</p> <p>For multi-module projects, by default, plugin will create virtualenv inside the root project directory in order to share the same environment for all modules (but this could be changed).</p> <p>Venv support could be disabled with <code>python.useVenv = false</code> option (virtualenv would be used in this case).</p>"},{"location":"getting-started/#usage","title":"Usage","text":"<p>Call python command:</p> <pre><code>tasks.register('cmd', PythonTask) {\n    command = \"-c print('sample')\"\n}\n</code></pre> <p>called: <code>python -c print('sample')</code> on win and <code>python -c exec(\"print('sample')\")</code> on *nix (exec applied automatically for compatibility)</p> <p>Note</p> <p>Each <code>PythonTask</code> would depend on <code>checkPython</code> and <code>pipInstall</code> tasks which would prepare python environment before actual execution.</p> <p>Call multi-line command:</p> <pre><code>tasks.register('cmd', PythonTask) {\n    command = \"-c \\\"import sys; print(sys.prefix)\\\"\"\n}\n</code></pre> <p>called: <code>python -c \"import sys; print(sys.prefix)\"</code> on win and <code>python -c exec(\"import sys; print(sys.prefix)\")</code> on *nix</p> <p>Note</p> <p>It is important to wrap script with space in quotes (otherwise parser will incorrectly parse arguments).</p> <p>See command parsing specifics and env variables usage</p> <p>String command is used for simplicity, but it could be array/collection of args:</p> <pre><code>tasks.register('script', PythonTask) { \n    command = ['path/to/script.py', '1', '2'] \n}\n</code></pre>"},{"location":"getting-started/#module","title":"Module","text":"<pre><code>tasks.register('mod', PythonTask) {\n    module = 'sample' \n    command = \"mod args\"\n}\n</code></pre> <p>called: <code>python -m sample mod args</code></p>"},{"location":"getting-started/#script","title":"Script","text":"<pre><code>tasks.register('script', PythonTask) { \n    command = \"path/to/script.py 1 2\"\n}\n</code></pre> <p>called: <code>python path/to/script.py 1 2</code> (arguments are optional, just for demo)</p>"},{"location":"getting-started/#non-default-python","title":"Non-default python","text":"<p>Python task would use python selected by <code>checkPython</code> task (global or detected virtualenv). If you need to use completely different python for some task, then it should be explicitly stated with <code>useCustomPython</code> property:</p> <pre><code>tasks.register('script', PythonTask) {\n    // global python (it would select python3 automatically on linux)\n    pythonPath = null\n    // force custom python for task\n    useCustomPython = true\n    command = ['path/to/script.py', '1', '2'] \n}\n</code></pre>"},{"location":"about/compatibility/","title":"Gradle compatibility","text":"<p>Plugin compiled for java 8, compatible with java 11 and 17. Works with python 2 and 3 (but python 2 not tested anymore) on windows and linux (and macos).</p> Gradle Version 7-8 4.1.0 5.3 3.0.0 5-5.2 2.3.0 4.x 1.2.0"},{"location":"about/history/","title":"Release notes","text":""},{"location":"about/history/#410-2024-11-09","title":"4.1.0 (2024-11-09)","text":"<ul> <li>Hide password inside --index-url pip parameter in console output (#146)</li> <li>Add python.indexUrl configuration option (to override default pip repository)</li> <li>Changed default docker image (python.docker.image) from python:3.11.8-alpine3.19 to python:3.12.7-alpine3.20</li> </ul>"},{"location":"about/history/#400-2024-04-13","title":"4.0.0 (2024-04-13)","text":"<ul> <li>(breaking) Drop gradle 5 and 6 support</li> <li>(breaking) All plugin tasks become abstract, so any custom task types should be abstract too</li> <li>(breaking) All tasks use lazy properties instead of convention mapping (affects custom tasks)</li> <li>Fix <code>alwaysInstallModules = true</code> not triggers pipInstall for non-strict requirements file (#94)   (required for case when requirements file links other files, which changes are not tracked)</li> <li>Add requirements file references (-r file) support under strict mode (#94)</li> <li>Configuration cache compatibility (#89)</li> <li>Changed virtualenv version installed by default (python.virtualenvVersion) from 20.4.2 to 20.25.1   (supports python 3.7 - 3.12)</li> <li>Changed default docker image (python.docker.image) from python:3.10.8-alpine3.15 to python:3.11.8-alpine3.19</li> <li>New options (python.):</li> <li>breakSystemPackages: adds --break-system-packages for pip install     May be required on linux to install virtualenv on apt-managed python (e.g. python3.12)</li> <li>docker.useHostNetwork: use host network for docker     Works only on linux. When enabled, all container ports automatically exposed on host     and configured port mappings ignored</li> <li>printStats: show all executed python commands (including plugin internal) at the end of the build (with timings)</li> <li>useVenv: use venv instead of virtualenv (enabled by default)     Venv is installed by default since python 3.3 which removes requirement to install virtualenv. (#77)     Fallback to virtualenv when venv not found. All current environments created with virtualenv     will still be working correctly.</li> <li>Add user home dir (\"~/\") support for the environment path (python.envPath)</li> <li>To use different python for PythonTask useCustomPython = true must be declared now   (otherwise, pythonPath select by checkPython task would be used (and task's pythonPath ignored))</li> </ul>"},{"location":"about/history/#300-2022-10-22","title":"3.0.0 (2022-10-22)","text":"<ul> <li>(breaking) Drop gradle 5.0-5.2 support (minimum required gradle is 5.3)</li> <li>Add docker support (python could be started in docker container without local python)<ul> <li>Add dockerChown and dockerExec methods for python tasks for customizations in doFirst or doLast closures</li> </ul> </li> <li>Add requirements file support (requirements.txt).<ul> <li>By default, requirements support is enabled in strict mode:   plugin reads file contents and expects only exact version matches (allows extracting module declarations   so external tools could easily parse and update dependencies).</li> <li>In non-strict mode, requirements file processing delegated to pip (no restrictions on declarations)</li> <li>New configuration section: python.requirements</li> </ul> </li> <li>Add global python binary validation to reveal PATH problems (might not be the same as user shell PATH)</li> <li>Add validateSystemBinary configuration to be able to disable validation (in case it would not work properly)</li> <li>Add cleanPython task for removing project-specific virtualenv</li> <li>Add python process output to exception message to be sure it will be visible on error (especially on CI)</li> <li>Fix potential memory leak due to gradle Project objects caching (#22)</li> <li>Fix concurrent virtualenv installation in multi-module project with parallel execution enabled (#19)</li> <li>Fix concurrent pipInstall into the same environment with parallel execution</li> </ul>"},{"location":"about/history/#230-2021-03-01","title":"2.3.0 (2021-03-01)","text":"<ul> <li>Support python installation from Windows Store (#14)</li> <li>Changed virtualenv version installed by default from 16.7.9 to 20.4.2   (because only recent versions could work correctly with python installed from Windows Store)</li> <li>Add minimal required virtualenv check: by default, it's virtualenv 16 (to not fail previously working environments).   But it is recommended to use at least 20.0.11 (compatible with Windows Store python). V20 changes pip installation   strategy in environment to the same version as bundled with virtualenv instead of always downloading new pip (which increase builds stability).   Configured with python.minVirtualenvVersion.</li> <li>Fix up-to-date check in pipInstall task for VCS modules (the latest pip changed freeze output syntax)</li> <li>Hide passwords in logs for pip extra index repository urls with credentials (extraIndexUrls config) (#12)</li> <li>Add general logged command cleaning mechanism to Python object for plugin authors (Pip object uses it for passwords hiding)</li> </ul>"},{"location":"about/history/#220-2020-04-06","title":"2.2.0 (2020-04-06)","text":"<ul> <li>Add support for <code>pip</code> flags: --trusted-host   and --extra-index-url (#10)   May be set in <code>python</code> extension or directly for <code>pip</code> tasks (<code>extraIndexUrls</code>, <code>trustedHosts</code>).   Flags applied only to compatible pip commands.</li> <li>Allow dashes in vcs module name (for example, now it is possible to specify <code>#egg=my-module-11.2</code>).   NOTE: This may lead to problems with versions also containing dashes (1.1-alpha.1), but   it may be easily changed manually (to version without dashes: 1.1.alpha.1)</li> <li>Move python configuration options from <code>PythonTask</code> to <code>BasePythonTask</code>:   <code>pythonArgs</code>, <code>environment</code>, <code>workDir</code>, <code>logLevel</code>. Now pip tasks could use   these options to fine tune python execution (under pip call).   NOTE: extraArgs was not moved because exact tasks (like pipInstall) could perform   multiple commands calls and applying args to all of them is not correct (most likely, fail the build).   Instead, tasks must implement their own support for additional args.</li> <li>Add free options to <code>pipInstall</code>: <code>pipInstall.options('--upgrade-strategy', 'only-if-needed')</code>.   It is not possible to support every possible pip flag with api so this manual customization   is required to cover wider range of use-cases.</li> <li>Fix gradle deprecation warnings on some tasks properties (#9)</li> <li>Add environment variables configuration in extension: <code>python.environment 'SAMPLE', 'value'</code></li> <li>Fix checkPython execution when running from daemon (gradle work dir may differ from project root:   confirmed case with gradle 6 on java 11).</li> <li>Use relative path to virtualenv when possible instead of always absolute</li> </ul>"},{"location":"about/history/#210-2020-03-17","title":"2.1.0 (2020-03-17)","text":"<ul> <li>Add environment variables support (#8):<ul> <li>Python object: <code>Python.environment</code> (single and map)</li> <li>Python task: <code>PythonTask.environment</code> (single and map)</li> </ul> </li> </ul>"},{"location":"about/history/#200-2020-03-13","title":"2.0.0 (2020-03-13)","text":"<ul> <li>(breaking) Drop java 7 support</li> <li>(breaking) Drop gradle 4 support</li> <li>Add <code>python.usePipCache</code> option to be able to disable cache for dependencies installation   (--no-cache-dir)   Also, option added to Pip object constructor and BasePipTask (with default from extension)</li> <li>Add <code>Python.getBinaryDir()</code> returning (in most cases) executed python binary folder   (based on <code>sys.executable</code> with fallback to <code>sys.prefix/bin</code>)</li> <li>Fix virtualenv installation fail when \"global\" python is already virtualenv due to --user flag usage   (like on travis now)<ul> <li>Add <code>Python.isVirtualenv()</code> method. Virtualenv is detected by <code>activate</code> script in python binary   (which may not be always accurate, but should work in the majority of cases)</li> <li><code>Pip</code> internally use <code>Python.isVirtualenv()</code> to prevent applying --user flag</li> <li>Configured (<code>envPath</code>) or created virtualenv is validated (shows error on incorrect configuration)</li> <li>Show warnings for cases when virtualenv is created from another virtualenv (because it may have side effects)</li> </ul> </li> <li>Add python extra args support (in contrast to extra agrs, applied after command, python args applied before):<ul> <li>Add <code>Python.pythonArgs</code> -  args applied just after python executable</li> <li>Add <code>PythonTask.pythonArgs</code></li> </ul> </li> <li>Add <code>Virtualenv.python</code> accessor to be able to configure additional arguments</li> <li>Add installed virtualenv version configuration: <code>python.virtualenvVersion</code>. This way, plugin will   always install only known to be working version and avoid side effects of \"just released\"   versions. By default, 16.7.9 would be installed because 20.0.x has some not fixed regressions</li> <li>Use gradle tasks configuration avoidance for lazy tasks initialization (no init when tasks not needed)</li> </ul>"},{"location":"about/history/#120-2018-08-30","title":"1.2.0 (2018-08-30)","text":"<ul> <li>Improve virtualenv usage in multi-module project (#5):<ul> <li>Fix virtualenv access from module on windows</li> <li>By default virtualenv is created in the root project and used for all modules   (breaking) note that before virtualenv was created inside module (on linux)</li> <li>Per module python setup is also possible by overriding envPath</li> </ul> </li> </ul>"},{"location":"about/history/#110-2018-05-29","title":"1.1.0 (2018-05-29)","text":"<ul> <li>Add vcs modules support in format: \"vcs+protocol://repo_url/@vcsVersion#egg=pkg-pkgVersion\" (#2)</li> <li>Support module features syntax: module[feature]:version (#3)</li> <li>PipModule api changes:<ul> <li>Added toPipInstallString(): must be used for installation command instead of toPipString()</li> </ul> </li> </ul>"},{"location":"about/history/#102-2018-04-18","title":"1.0.2 (2018-04-18)","text":"<ul> <li>Fix pip 10 compatibility (#1)</li> </ul>"},{"location":"about/history/#101-2017-12-26","title":"1.0.1 (2017-12-26)","text":"<ul> <li>Fix python command recognition: avoid wrapping for -c module argument</li> <li>Support escaped space and quote during command string parsing</li> <li>Support command definition as array/list in PythonTask</li> </ul>"},{"location":"about/history/#100-2017-12-20","title":"1.0.0 (2017-12-20)","text":"<ul> <li>Initial release</li> </ul>"},{"location":"about/license/","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright \u00a9 2017-2024, Vyacheslav Rusakov</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"guide/ci/","title":"CI","text":"<p>Example configuration, required to use python on CI servers.</p> <p>Warning</p> <p>Docker support will not work on most windows CI servers (like appveyor). Linux CI is completely ok (e.g. works out of the box on github actions)</p>"},{"location":"guide/ci/#github-actions","title":"GitHub actions","text":"<pre><code>name: CI\n\non:\n  push:\n  pull_request:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    name: Java ${{ matrix.java }}, python ${{ matrix.python }}\n    strategy:\n      matrix:\n        java: [8, 11]\n        python: ['3.8', '3.12']\n\n      # reduce matrix, if required\n      exclude:\n          - java: 8\n            python: '3.12'  \n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up JDK ${{ matrix.java }}\n        uses: actions/setup-java@v1\n        with:\n          java-version: ${{ matrix.java }}\n\n      - name: Set up Python ${{ matrix.python }}\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{matrix.python}}\n\n      - name: Build\n        run: |\n          chmod +x gradlew\n          python --version\n          pip --version\n          ./gradlew assemble --no-daemon\n\n      - name: Test\n        run: ./gradlew check --no-daemon\n</code></pre>"},{"location":"guide/ci/#appveyour","title":"Appveyour","text":"<p>To make plugin work on appveyour you'll need to add python to path:</p> <pre><code>environment:\n    matrix:\n        - job_name: Java 8, python 3.8\n          JAVA_HOME: C:\\Program Files\\Java\\jdk1.8.0\n          PYTHON: \"C:\\\\Python38-x64\"\n        - job_name: Java 17, python 3.12\n          JAVA_HOME: C:\\Program Files\\Java\\jdk17\n          appveyor_build_worker_image: Visual Studio 2019\n          PYTHON: \"C:\\\\Python312-x64\"  \n\ninstall:\n  - set PATH=%PYTHON%;%PYTHON%\\\\Scripts;%PATH%\n  - python --version\n</code></pre> <p>Now plugin would be able to find python binary.</p> <p>See available pythons matrix for more info.</p>"},{"location":"guide/ci/#travis","title":"Travis","text":"<p>To make plugin work on travis you'll need to install python3 packages:</p> <pre><code>language: java  \ndist: bionic\njdk: openjdk8\n\naddons:\n  apt:\n    packages:\n    - python3\n    - python3-pip\n    - python3-setuptools \n\nbefore_install:\n  - python3 --version\n  - pip3 --version\n  - pip3 install -U pip\n</code></pre> <p>It will be python 3.6 by default (for bionic).</p>"},{"location":"guide/ci/#environment-caching","title":"Environment caching","text":"<p>To avoid creating virtual environments on each execution, it makes sense to move environment location from the default <code>.gradle/python</code> (inside project) outside the project:</p> <pre><code>python.envPath = '~/.myProjectEnv'\n</code></pre> <p>Virtual environment created inside the user directory and so could be easily cached now.</p> <p>NOTE: Only <code>envPath</code> property supports home directory reference (<code>~/</code>). If you need it in other places then use manual workaround: <code>'~/mypath/'.replace('~', System.getProperty(\"user.home\"))</code></p>"},{"location":"guide/ci/#system-packages","title":"System packages","text":"<p>On linux distributions, some python packages could be managed with external packages (like python3-venv, python3-virtualenv, etc.).</p> <p>If your build is not using virtual environment and still needs to install such packages, it would lead to error:</p> <pre><code>error: externally-managed-environment\n\n\u00d7 This environment is externally managed\n\u2570\u2500&gt; To install Python packages system-wide, try apt install\n    python3-xyz, where xyz is the package you are trying to\n    install.\n</code></pre> <p>To work around this problem, use breakSystemPackages option:</p> <pre><code>python {\n    breakSystemPackages = true\n}\n</code></pre>"},{"location":"guide/configuration/","title":"Configuration","text":""},{"location":"guide/configuration/#python-location","title":"Python location","text":"<p>On linux, plugin will use <code>python3</code> if available (and fall back to <code>python</code> if not). To use different binary use:</p> <pre><code>python {\n    pythonBinary = 'python'\n}\n</code></pre> <p>This will force python 2 for linux. Also, this may be handy if python binary is named differently.</p> <p>To use non-global python:</p> <pre><code>python {\n    pythonPath = 'path/to/python/binary/'\n}\n</code></pre> <p><code>pythonPath</code> must be set to directory containing python binary (e.g. 'path/to/python/binary/python.exe')</p> <p>Note</p> <p><code>pythonPath</code> is ignored when virtualenv used (virtualenv located at <code>python.envPath</code> already exists).</p> <p>Important</p> <p>If python can't be found, please pay attention to PATH: most likely, it is different from your shell PATH (for example, this might happen when using pyenv). To check PATH, just put somewhere inside build script:</p> <pre><code>println System.getenv('PATH')\n</code></pre>"},{"location":"guide/configuration/#minimal-python-and-pip-versions","title":"Minimal python and pip versions","text":"<p>To set python version constraint:</p> <pre><code>python {\n    minPythonVersion = '3.2'\n}\n</code></pre> <p>Python version format is: major.minor.micro. Constraint may include any number of levels: '3', '3.1', '2.7.5'</p> <p>The same way pip version could be restricted:</p> <pre><code>python {\n    minPipVersion = '9.0.1'\n}\n</code></pre>"},{"location":"guide/configuration/#virtualenv","title":"Virtualenv","text":"<p>When you declare any pip modules, plugin will try to use venv or  virtualenv to install required modules locally (for current project only).</p> <p>By default, plugin would use venv, usually bundled with python (since 3.3).  Only if venv is not detected, plugin would fall back to virtualenv.</p> <p>If, for some reason, you don't want to use venv at all and prefer virtualenv:</p> <pre><code>python.useVenv = false\n</code></pre> <p>Note</p> <p>All virtualenv-related options are ignored when venv is detected (and not disabled to use).</p> <p>If virtualenv is not installed - it will be installed automatically in <code>--user</code> scope. If you don't want automatic installation then disable it:</p> <pre><code>python.installVirtualenv = false\n</code></pre> <p>Plugin installs exact pip version declared in <code>python.virtualenvVersion</code> (by default, 20.25.1). This way, plugin will always install only known to be working version and avoid side effects of \"just released\" versions (note that pip 20 is a major rewrite and may still contain side effects).</p> <p>In any case, plugin checks if virtualenv is already installed and use it to create local environment (if not, then fall back to  <code>--user</code> scope by default). Virtualenv usage is driven by declared scope, so if you don't want to use it set:</p> <pre><code>python.scope = USER // or GLOBAL\n</code></pre> <p>With USER (or GLOBAL) scope, virtualenv will not be used, even if it's already created in project (plugin will ignore it and use global python).</p> <p>If you already use virtualenv in your project (have created manually environment), then simply point plugin to use it:</p> <pre><code>python.envPath = 'path/to/your/env'\n</code></pre> <p>Tip</p> <p>envPath value might contain user home reference like <code>envPath = '~/.myproject</code>. This might be useful for CI where created environment should be cached. </p> <p>It will automatically change <code>pythonPath</code> configuration accordingly.</p> <p>Note</p> <p>Plugin will not create environment if you don't use any modules. If you still want to use project specific environment (without declared pip modules) then create it manually: <code>python3 -m virtualenv .gradle/python</code> (default location). Plugin will recognize existing env and use it.</p> <p>Important</p> <p>Virtualenv creates local python copy (by default in <code>.gradle/python</code>). Copy is created from global python and later used instead of global python. If you want to change used python version in the environment, then manually remove <code>.gradle/python</code> so it could be created again (from global python).</p> <p>To copy environment instead of symlinking (default) set (--always-copy (virtualenv)  or --copies (venv)):</p> <pre><code>python.envCopy = true\n</code></pre>"},{"location":"guide/configuration/#pip","title":"Pip","text":"<p>By default, all installed python modules are printed to console after pip installations using <code>pip list</code> (of course, if at least one module declared for installation). This should simplify problems resolution (show used transitive dependencies versions).</p> <p>To switch off:</p> <pre><code>python {\n    showInstalledVersions = false\n}\n</code></pre> <p>You can always see the list of installed modules with <code>pipList</code> task (exactly the same list as after pipInstall).</p> <p>Note</p> <p>If global python is used with USER scope and some modules were manually installed in global scope then they will not be shown by pipList (and after pip install). To see all modules:</p> <pre><code>pipList.all = true\n</code></pre> <p>Global modules are hidden by default (for USER scope) because on linux there are a lot of system modules pre-installed.</p> <p>By default, 'pip install' is not called for modules already installed with correct version. In most situations this is preferred behaviour, but if you need to be sure about dependencies then force installation:</p> <pre><code>python {\n    alwaysInstallModules = true\n}\n</code></pre>"},{"location":"guide/configuration/#reference","title":"Reference","text":"<p>All configuration options with default values:</p> <pre><code>python {\n   // path to python binary (global by default)\n   pythonPath\n   // python binary name (python or python3 by default)\n   pythonBinary\n   // search python in system PATH and fail build if not found (incorrect PATH reveal)\n   validateSystemBinary = true \n   // additional environment variables, visible for all python commands\n   environment = [:]\n\n   // minimal required python version (m.m.m)\n   minPythonVersion\n   // minimal required pip version (m.m.m)\n   minPipVersion = '9'   \n\n   // show all installed modules versions after pip installation\n   showInstalledVersions = true\n   // always call module install, even if correct version is already installed\n   alwaysInstallModules = false\n   // may be used to disable pip cache (--no-cache-dir option)\n   usePipCache = true\n   // required to overcome \"error: externally-managed-environment\" error on linux (--break-system-packages)\n   breakSystemPackages = false\n   // override default pip repository (--index-url option) \n   indexUrl = null\n   // additional pip repositories (--extra-index-url option)\n   extraIndexUrls = []\n   // trusted hosts for pip install (--trusted-host option)\n   trustedHosts = []\n\n\n   // pip modules installation scope (project local, os user dir, global) \n   scope = VIRTUALENV_OR_USER\n   // use venv instead of virtualenv (auto fall back to virtualenv if not found)\n   useVenv = true \n   // automatically install virtualenv module (if pip modules declared and scope allows)   \n   installVirtualenv = true\n   // if virtualenv not installed (in --user scope), plugin will install exactly this version\n   // (known to be working version) to avoid side effects\n   virtualenvVersion = '20.25.1'\n   // minimal required virtualenv (v20 is recommended, but by default 16 set to not fail previous\n  // setups)\n   minVirtualenvVersion = '16'\n   // used virtualenv path (if virtualenv used, see 'scope')\n   envPath = '.gradle/python'\n   // copy virtualenv instead of symlink when created (venv --copies and virtualenv --always-copy)\n   envCopy = false\n   // print stats for all executed python command (including hidden)  \n   printStats = false \n\n   requirements {\n       // use requirements.txt file\n       use = true\n       // file to use as requirements (path to file)\n       file = 'requirements.txt'\n       // requirements restriction (exact versions, syntax subset support)\n       // false delegates requirements loading to pip\n       strict = true\n   }\n\n   docker {\n      // enables docker support \n      use = false\n      // image to use \n      image = 'python:3.12.7-alpine3.20'\n      // windows containers indicator (not supported now, done for the future) \n      windows = false\n      // use host network directly (works only on linux) \n      useHostNetwork = false \n      // docker ports to expose into host (direct 5000 or mapped '5000:6000')\n      ports = [] \n   } \n}\n</code></pre> <p>Note that in case of multi-module project envPath is set to '.gradle/python' inside the root project, even if plugin is activated inside module (see multi-module setup).</p>"},{"location":"guide/configuration/#pythontask","title":"PythonTask","text":"<p>PythonTask configuration:</p> Property Description pythonPath Path to python binary. By default, property ignored because checkPython task selects correct path useCustomPath Force pythonPath property use instead of path selected by checkPython task (e.g. to use global python instead of environment) pythonBinary Python binary name. By default, python3 on linux and python otherwise. validateSystemBinary Search python binary in PATH and fail build to reveal PATH problems workDir Working directory (important if called script/module do file operations). By default, it's a project root createWorkDir Automatically create working directory if does not exist. Enabled by default module Module name to call command on (if command not set module called directly). Useful for derived tasks. command Python command to execute (string, array, iterable) logLevel Logging level for python output. By default is <code>LIFECYCLE</code> (visible in console). To hide output use <code>LogLevel.INFO</code> pythonArgs Extra python arguments applied just after python binary. Useful for declaring common python options (-I, -S, etc.) extraArgs Extra arguments applied at the end of declared command (usually module arguments). Useful for derived tasks to declare default options outputPrefix Prefix, applied for each line of python output. By default is '\\t' to identify output for called gradle command environment Process specific environment variables docker.use Enable docker support docker.image Python image to use docker.windows Windows image use. Not usefule now as testcontainers can't run on windows containers (imlpemented for the future) docker.useHostNetwork Use host network in container (exposed ports ignored in this case). Only for linux (ignored on other platforms) docker.ports Exposed ports from docker container docker.exclusive Enable exclusive container mode (immediate logs for long-running tasks) <p>Also, task provide extra methods:</p> <ul> <li><code>pythonArgs(String... args)</code> to declare extra python arguments (shortcut to append values to pythonArgs property).</li> <li><code>extraArgs(String... args)</code> to declare extra arguments (shortcut to append values to extraArgs property).</li> <li><code>environment(String var, Object value)</code> to set custom environment variable (shortcut to append values to environment property)</li> <li><code>environment(Map&lt;String, Object&gt; vars)</code> to set multiple custom environment variables at once (shortcut to append values to environment property)</li> <li><code>docker.ports(Object... ports)</code> to set container ports to expose (direct 5000 or mapped '5000:6000')</li> <li><code>dockerChown(&lt;String or Path&gt; path)</code> to fix root user on paths created inside container for linux</li> <li><code>dockerExec(Object command)</code> to run native command inside container</li> </ul>"},{"location":"guide/configuration/#pipinstalltask","title":"PipInstallTask","text":"<p>Default pip installation task is registered as <code>pipInstall</code> and used to install modules, declared in global configuration. Custom task(s) may be used, if required:</p> <pre><code>tasks.register('myPipInst', PipInstallTask) {\n    pip 'mod:1', 'other:2'\n}\n</code></pre> <p>Configuration:</p> Property Description pythonPath Path to python binary. By default, property ignored because checkPython task selects correct path useCustomPath Force pythonPath property use instead of path selected by checkPython task (e.g. to use global python instead of environment) pythonBinary Python binary name. By default, python3 on linux and python otherwise. validateSystemBinary Search python binary in PATH and fail build to reveal PATH problems pythonArgs Extra python arguments applied just after python binary. Useful for declaring common python options (-I, -S, etc.) environment Process specific environment variables modules Modules to install. In most cases configured indirectly with <code>pip(..)</code> task methods. By default, modules from global configuration. userScope Use current user scope (<code>--user</code> flag). Enabled by default to avoid permission problems on *nix (global configuration). showInstalledVersions Perform <code>pip list</code> after installation. By default use global configuration value alwaysInstallModules Call <code>pip install module</code> for all declared modules, even if it is already installed with correct version. By default use global configuration value useCache Can be used to disable pip cache (--no-cache-dir) indexUrl Override default pip repository (--index-url) extraIndexUrls Additional pip repositories (--extra-index-url) trustedHosts / trusted hosts (--trusted-host) options additional pip install options requirements Requirements file to use strictRequirements Strict or native requirements file processing mode envPath Virtual environment path (require to chown dir inside docker) <p>And, as shown above, custom methods:</p> <ul> <li><code>pip(String... modules)</code></li> <li><code>pip(Iterable&lt;String&gt; modules)</code></li> <li><code>options(String... options)</code></li> </ul>"},{"location":"guide/docker/","title":"Docker","text":"<p>Instead of direct python usage, plugin could use python inside docker container (docker must be installed).</p> <p>To enable docker support:</p> <pre><code>python.docker.use = true\n</code></pre> <p>Important</p> <p>Docker support is implemented with testcontainers because testcontainers will always correctly cleanup used containers (extremely important for build failures or \"infinite\" runs).  But testcontainers currently only work on linux containers and so you will not be able to use  windows python containers.  It does not mean it can't be used on windows: it will run on WSL2 (default mode) or Hyper-V (running linux containers on windows).</p> <p>Warning</p> <p>Testcontainers will not work on windows server and so  docker support will not work on most windows CI servers (like appveyor).  Linux CI is completely ok (e.g. works out of the box on github actions)</p>"},{"location":"guide/docker/#image","title":"Image","text":"<p>By default, official python docker image used: <code>python:3.12.7-alpine3.20</code>. But you can change it to any other image containing python:</p> <pre><code>python.docker.image = 'python:3.12.7-alpine3.20'\n</code></pre> <p>Tip</p> <p>It is highly recommended to always specify exact tags for reproducible builds!</p> <p>Simple image declaration above would lead to docker hub, but if you need to use  custom repository simply declare it: <code>registry.mycompany.com/mirror/python:3.12.7-alpine3.20</code></p>"},{"location":"guide/docker/#behaviour","title":"Behaviour","text":"<ul> <li>Docker container started before first python call (in <code>checkPython</code> task) and stopped after build completion.</li> <li>Entire project directory is mapped inside container (so python process would be able to access any project file)</li> <li>Working directory would be set to project root</li> </ul> <p>It all mentioned in logs:</p> <pre><code>&gt; Task :checkPython\n[docker] container 'python:3.12.7-alpine3.20' (/focused_wing) started in 1.92s\n    Mount           /home/user/projects/project:/usr/src/project\n    Work dir        /usr/src/project\n</code></pre> <p>Note</p> <p>Docker container kept started to speed-up execution (avoid re-starting it for each command), but this also cause python command logs to appear only after execution (current api limitation). This might be a bit confusing for non-immediate tasks like <code>pipInstall</code>, but it's a compromise.</p> <p>Docker containers are stateless (removed after execution) and so, if pip modules used, prefer virtualenv mode (default) because in this case virtualenv would be created inside  project \"caching\" all required pip packages. so workflow would be:</p> <ul> <li>Docker container started</li> <li>Virtualenv installed into it</li> <li>Virtualenv folder created (inside project)</li> <li>Pip install executed for created python copy</li> </ul> <p>On next execution, created environment would be simply used (same as with direct python usage).</p> <p>Note</p> <p>Gradle itself is executed on host and only python commands are executed inside container.</p>"},{"location":"guide/docker/#configuration","title":"Configuration","text":"<p><code>python.docker</code> properties:</p> name Description Default use Enable docker support false image Image name (could be full path with repository) python:3.12.7-alpine3.20 windows Windows container OS. Windows containers support implemented in plugin, but currently not supported by testcontainers false ports Ports to expose from container (for long-lived commands) <p>Note</p> <p>Docker support is experimental and, current configuration is a minimal working configuration. If you have a case requiring more configuration options, please create new issue</p> <p>Docker configuration could be changed globally or per-task. For example:</p> <pre><code>tasks.register('sample', PythonTask) {\n        workDir 'src/main'\n        docker.ports 5000\n        environment 'foo', 'bar'\n        command = '-c print(\\'samplee\\')'\n    }\n</code></pre> <p>This changes <code>workDir</code>, docker exposed ports and environment variables.</p> <p>Plugin will detect these changes and will restart container automatically to properly apply configuration (you'll see it in log).</p> <p>Tip</p> <p>To avoid redundant container restarts prefer global docker configuration. But <code>workDir</code> could be set only on task level</p> <p>Task properties affecting container restart (because they could be specified only before container startup):</p> name Description docker.ports container restarts if ports configuration differ (not all required ports exposed) environment container restarts if varaibles change (if more variables used for container start - it's ok) workDir container restarts if work dir changes <p>Note</p> <p>Task also has <code>docker.use</code> option and so docker could be enabled/disabled for exact task, but it will fail if pip modules required   </p> <p>Tip</p> <p>All paths used in python commands are processed to represent correct in-container paths. This should simplify usage as no changes required to use task with direct python and inside docker. Also, all path separators changed according to target os (important when running container from windows host).</p> <p>Note</p> <p>Environment variable values are not logged (only keys logged) because they might contain secrets.</p>"},{"location":"guide/docker/#exclusive-mode","title":"Exclusive mode","text":"<p>There is one configuration option available only for tasks - exclusive mode:</p> <pre><code>tasks.register('sample', PythonTask) {\n        docker.exclusive = true\n        module = 'mkdocs'\n        command = 'serve'\n    }\n</code></pre> <p>In this case new docker container would be started using python command as container command (command keeping container alive). This mode required for infinite or just long tasks because this way logs immediately streamed into gradle console. This is ideal for various dev-servers (like mkdocs dev server in example above).</p> <p>Exclusive task does not stop currently running (shared) container (because other (potential) python tasks may need it).</p> <p>Warning</p> <p>When running infinite task (e.g. dev server) the only way to stop it is using force (usually stop from IDE). After such emergency stop containers may live for about ~10s (keep it in mind), but, eventually, they should be removed.</p>"},{"location":"guide/docker/#ports","title":"Ports","text":"<p>Exposing container ports for host might be useful for long-lived tasks (usually, <code>exclusive</code> tasks, but not necessary).</p> <p>There is a special method for ports configuration in both global extension and tasks:</p> <pre><code>python.docker.ports 5000, 5010\n</code></pre> <p>Ports might be declared as integer and string. In this simple case, ports would be mapped on the same host ports.</p> <p>In order to map port on different host port use colon-syntax:</p> <pre><code>python.docker.ports '5000:5001', '5010:5011'\n</code></pre> <p>Here docker port 5000 mapped to host 5001 and 5010 to 5011</p>"},{"location":"guide/docker/#different-image","title":"Different image","text":"<p>Custom task can use a different container image (than declared in global extension) if required (no limits):</p> <pre><code>tasks.register('sample', PythonTask) {\n        docker.image = 'python:3.10.7-bullseye'\n        module = 'mkdocs'\n        command = 'serve'\n    }\n</code></pre> <p>In this case, new container would be started just before python command (and will stay up until gradle finished build).</p>"},{"location":"guide/docker/#user-permissions","title":"User permissions","text":"<p>Docker works as root user and so all files created inside mounted project would be owned by root. On windows and mac volume mounted using network with permissions mapping (no root-owned files on host). But on linux container root permissions would become host root permissions. As a result,  you'll need a root rights to simply remove these files (cleanup).</p> <p>In order to fix this situation, plugin will execute <code>chown</code> on created files (with uid and gid  of user owning project directory (not current user)). This will work for <code>checkPython</code> and <code>pipInstall</code> tasks.</p> <p>Note</p> <p>As long as uid and gid used instead of user/group name, container does not need to have user with the same uid:gid</p> <p>If your custom python task create other files, then you should fix permissions manually with help of <code>dockerChown</code> method available on all python tasks. You can use <code>doFirst</code> or <code>doLast</code> callbacks. For example, suppose python command creates a file:</p> <pre><code>tasks.register('sample', PythonTask) {\n    command = '-c \"with open(\\'build/temp.txt\\', \\'w+\\') as f: pass\"'\n    doLast {\n        dockerChown 'build/temp.txt'\n    }\n}\n</code></pre> <p>Without \"chown\" used, next <code>gradlew clean</code> execution would fail.</p> <p>Note</p> <p><code>doLast</code> is executed only after successful task execution. If you need it to be called in any case you'll have to use gradle graph:</p> <pre><code>gradle.taskGraph.afterTask {task, state -&gt;\n    // execute chown even if task fails\n    if (task instanceof PythonTask) {\n        (task as PythonTask).dockerChown('some/path')\n    }\n}\n</code></pre> <p>Important</p> <p><code>dockerChown</code> will work only for linux container when host is also linux and when docker used, so it is safe to call it without conditions. Also, specified directory (or file) path must exist on local fs (plugin will rewrite path into correct docker path, but first it checks for local existence). </p>"},{"location":"guide/docker/#docker-commands","title":"Docker commands","text":"<p>There is also a way to execute any command inside started docker container with <code>dockerExec</code> method available on all  python tasks:</p> <pre><code>tasks.register('sample', PythonTask) {\n    doFirst {\n        dockerExec 'ls -l /usr/src/'\n    }\n    command = '-c print(\\'samplee\\')'\n}\n</code></pre> <p>Tip</p> <p>As with python commands, docker command could be specified as simple string (will be split by spaces) or as array: <code>['ls', '-l', '/usr/src/']</code> (suitable in complex cases when command can't be correctly parsed automatically) </p> <p>Docker command output would be printed in console:</p> <pre><code>[docker] ls -l /usr/src/\n     total 4\n     drwx------    3 1000     1000          4096 Oct 21 08:02 project\n</code></pre> <p><code>dockerExec</code> returns command exit code which might be used for conditions:</p> <pre><code>if (dockerExec(...) == 0) {\n    // do something on success\n}\n</code></pre> <p>Note</p> <p>When docker not enabled, <code>dockerExec</code> returns -1 and do nothing</p>"},{"location":"guide/docker/#concurrency","title":"Concurrency","text":"<p>Any number of docker images could be used during the build. Different images would work concurrently. Different tags for the same image would be started as different containers.</p> <p>Execution is synchronized by docker image: in multi-module project or with parallel build only one python command would be executed in container at a time (but commands could run in different containers concurrently).</p> <p>This synchronization applied to minimize potential edge cases (simpler to investigate problems, avoid side effects). Later this could change (based on feedback).</p>"},{"location":"guide/docker/#testcontainers-configuration","title":"Testcontainers configuration","text":"<p>In most cases, additional testcontainers configuration is not required, except special cases.</p> <p>For example, suppose, you need to disable ryuk container usage  (image used for proper shutdown and may not be required in CI environment with already properly implemented shutdown).</p> <p>Either declare environment variable (before running gradle or globally):</p> <pre><code>export TESTCONTAINERS_RYUK_DISABLED=true\n</code></pre> <p>or create <code>~/.testcontainers.properties</code> configuration file:</p> <pre><code>ryuk.disabled=true\n</code></pre> <p>Note</p> <p>Environment variable name is <code>TESTCONTAINERS_</code> prefix + uppercased property name with <code>.</code> replaced with <code>_</code></p> <p>See possible options in testcontainers docs</p>"},{"location":"guide/docker/#private-docker-registry","title":"Private docker registry","text":"<p>If you need to use private registry instead of docker hub:  configure testcontainers directly.</p> <p>Either export environment variable (before running gradle):</p> <pre><code>export TESTCONTAINERS_HUB_IMAGE_NAME_PREFIX=registry.mycompany.com/mirror/\n\n./gradlew runSomePythonTask\n</code></pre> <p>Or update <code>~/.testcontainers.properties</code> configuration file:</p> <pre><code>hub.image.name.prefix=registry.mycompany.com/mirror/\n</code></pre> <p>Important</p> <p>Slash at the end is required! Testcontainers will simply append this prefix for used containers (but only if container is not declared with a full path).  An example of prefixed path: <code>registry.mycompany.com/mirror/testcontainers/ryuk:0.6.0</code></p> <p>Private registry must contain required testcontainers images (in most cases, just ryuk is required).</p>"},{"location":"guide/docker/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/docker/#testcontainers-check-docker-just-once","title":"Testcontainers check docker just once","text":"<p>Testcontainers remembers not found docker environment error (e.g. docker was simply not started) inside local static  variable. But, as docker was executed inside gradle daemon, this state remains, and you can see error:</p> <pre><code>Previous attempts to find a Docker environment failed. Will not retry. Please see logs and check configuration\n</code></pre> <p>It will continue showing this even if docker already started (it doesn't check at all).</p> <p>To resolve this simply stop gradle daemons:</p> <pre><code>gradlew --stop\n</code></pre>"},{"location":"guide/docker/#pip-root-user-warning","title":"Pip root user warning","text":"<p>As root user used inside container, you'll see the following warning:</p> <pre><code>WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv\n</code></pre> <p>It's just a warning, but if you want to remove it:</p> <pre><code>python.environment 'PIP_ROOT_USER_ACTION', 'ignore' \n</code></pre>"},{"location":"guide/docker/#network-problem","title":"Network problem","text":"<p>You may face a connection error like this:</p> <pre><code>Using python 3.11.8 from /usr/local (python3)\nUsing pip 24.0 from /usr/local/lib/python3.11/site-packages/pip (python 3.11)\n     WARNING: Package(s) not found: virtualenv\n[python] python3 -m pip install virtualenv==20.25.1 --user\n     WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('&lt;pip._vendor.urllib3.connection.HTTPSConnection object at 0x75a5aad9e350&gt;: Failed to establish a new connection: [Errno -3] Try again')': /simple/virtualenv/\n     WARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('&lt;pip._vendor.urllib3.connection.HTTPSConnection object at 0x75a5aad9ead0&gt;: Failed to establish a new connection: [Errno -3] Try again')': /simple/virtualenv/\n     WARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('&lt;pip._vendor.urllib3.connection.HTTPSConnection object at 0x75a5aad9f250&gt;: Failed to establish a new connection: [Errno -3] Try again')': /simple/virtualenv/\n     WARNING: Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('&lt;pip._vendor.urllib3.connection.HTTPSConnection object at 0x75a5aad9fa50&gt;: Failed to establish a new connection: [Errno -3] Try again')': /simple/virtualenv/\n     WARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('&lt;pip._vendor.urllib3.connection.HTTPSConnection object at 0x75a5aadac450&gt;: Failed to establish a new connection: [Errno -3] Try again')': /simple/virtualenv/\n     ERROR: Could not find a version that satisfies the requirement virtualenv==20.25.1 (from versions: none)\n     ERROR: No matching distribution found for virtualenv==20.25.1\n</code></pre> <p>It may appear, for example, due to enabled VPN on host.</p> <p>For linux (not mac!), the simplest workaround is to use host network directly:</p> <pre><code>python {\n    docker {\n        use = true\n        useHostNetwork = true\n    }\n}\n</code></pre> <p>This way container would share the same network instead of creating a separate network with NAT. In this case, port mappings would not work (would be ignored) because all container ports are already available on host.</p>"},{"location":"guide/modules/","title":"Pip modules","text":"<p>If additional pip modules required:</p> <pre><code>python.pip 'module1:1.0', 'module2:1.0'\n</code></pre> <p>or</p> <pre><code>python {\n    pip 'module1:1.0'\n    pip 'module2:1.0'\n}\n</code></pre> <p>Module format is: <code>name:version</code> (will mean <code>name==version</code> in pip notion). Non-strict version definition is not allowed (for obvious reasons). Dependencies are installed in declaration order. If duplicate declaration specified then only the latest declaration will be used:</p> <pre><code>python.pip 'module1:2.0', 'module2:1.0', 'module1:1.0' \n</code></pre> <p>Will install version 1.0 of module1 because it was the latest declaration. \"Module overrides\" works for all declaration types (see below): the latest declared module version always wins.</p> <p>Dependencies are installed with <code>pipInstall</code> task which is called before any declared <code>PythonTask</code>.</p> <p>By default, dependencies are installed inside project specific virtualenv (project specific copy of python environment,  configured with <code>python.envPath</code>).</p> <p>Behaviour matrix for possible <code>scope</code> and <code>installVirtualenv</code> configurations:</p> scope installVirtualenv Behaviour default GLOBAL ignored packages installed in global scope (<code>pip install name</code>) USER ignored packages installed in user scope (<code>pip install name --user</code>) VIRTUALENV_OR_USER true if virtualenv not installed, install it in user scope; create project specific virtualenv and use it default VIRTUALENV_OR_USER false when virtualenv is not installed install packages in user scope (same as USER); when virtualenv installed create project specific virtualenv and use it VIRTUALENV true if virtualenv not installed, install it in user scope; create project specific virtualenv and use it VIRTUALENV false throw error when virtualenv not installed <p>Note</p> <p>By default, plugin tries to use venv instead of virtualenv, which is usually installed by default with python (so no additional installations required)</p> <p>Note that <code>VIRTUALENV + true</code> and <code>VIRTUALENV_OR_USER + true</code> behaviours are the same. Different scope name here describes behavior for unexpected <code>installVirtualenv=false</code> change (to fail or fallback to user scope).</p> <p><code>USER</code> and <code>GLOBAL</code> scopes will ignore local (virtual)environment, even if project-specific environment was created before, with these options global python will be used instead.  </p>"},{"location":"guide/modules/#pip-module-extra-features","title":"Pip module extra features","text":"<p>You can declare modules with extra features in module name to install special version of module (with enabled features):</p> <pre><code>python.pip 'requests[socks,security]:2.18.4'\n</code></pre> <p>Important</p> <p>It is impossible to track if this \"variation\" of module is installed, so plugin performs up-to-date check for such modules by name only (for example, if 'requests==2.18.4' is already installed). For most cases, this is suitable behaviour because, by default, modules are installed in virtualenv and so you will always have correct module installed. For other cases, you can disable up-to-date checks (delegate all dependencies logic to pip): <code>python.alwaysInstallModules = true</code></p>"},{"location":"guide/modules/#vcs-pip-modules","title":"VCS pip modules","text":"<p>You can declare vcs modules: modules installed directly from version control (e.g. git, svn). Format:</p> <pre><code>vcs+protocol://repo_url/@vcsVersion#egg=pkg-pkgVersion\n</code></pre> <ul> <li><code>@vcsVersion</code> part is required: prefer using commit version or tag for reproducible builds</li> <li><code>-pkgVersion</code> is installed module version. Required to be able to compare declared plugin with installed version.</li> </ul> <p>For example:</p> <pre><code>python.pip 'git+https://github.com/ictxiangxin/boson/@b52727f7170acbedc5a1b4e1df03972bd9bb85e3#egg=boson-0.9'\n</code></pre> <p>Declares module <code>boson</code> version <code>0.9</code>, installed from git commit <code>b52727f7170acbedc5a1b4e1df03972bd9bb85e3</code> (it may be tag name or branch, but prefer not using branch names).</p> <p><code>pipInstall</code> will be considered up-to-date if <code>boson==0.9</code> is already installed. Note that declared module version is completely free: you can set any version (0.10, 1.2, etc.), it is not checked and used only for up-to-date validation.</p> <p>Warning</p> <p>Module version part assumed to follow the last dash, so if you specify version like <code>somethinf-12.0-alpha.1</code> it would be parsed incorrectly (as package <code>somethinf-12.0</code> version <code>alpha.1</code>)! Don't use dashes in version!</p> <p>Vcs module installation is: source checkout and module build (using setup.py). You may need to specify subdirectory as <code>&amp;subdirectory=pkg_dir</code> (see docs)</p> <p>To avoid installation problems, package version is not used for actual installation (in spite of the fact that its official convention, it doesn't work in some cases). For example, module above will be installed as (without <code>-0.9</code>):</p> <pre><code>pip install git+https://github.com/ictxiangxin/boson/@b52727f7170acbedc5a1b4e1df03972bd9bb85e3#egg=boson\n</code></pre> <p>All pip supported vcs could be used: git, svn, hg, bzr</p> <p>If up-to-date logic, implemented by <code>pipInstall</code> task, does not suit your needs, you can always disable it with <code>python.alwaysInstallModules = true</code> (pip always called). But this will be slower.</p> <p>Note</p> <p>Since pip 20, compiled vcs module is cached (before it was build on each execution), but it is possible to disable cache (for all modules) with <code>python.usePipCache=false</code> configuration (applies --no-cache-dir pip flag)</p>"},{"location":"guide/modules/#custom-pip-repository","title":"Custom pip repository","text":"<p>To override default pip repository (https://pypi.org/simple) (for example, to seld-hosted):</p> <pre><code>python {\n    indexUrl = \"http://custom-url.com\"\n}\n</code></pre> <p>or with shortcut method</p> <pre><code>python {\n    indexUrl \"http://custom-url.com\"\n}\n</code></pre> <p>Index url will be applied as --index-url flag for pip commands supporting it: install, download, list and wheel. By default, it only affects <code>pipInstall</code> and <code>pipList</code> tasks. Applied for all <code>BasePipTask</code>, so if you have custom pip tasks, it would be affected too.</p> <p>In case of ssl problems (stale or self-signed certificated), mark domains as trusted (see example below)</p>"},{"location":"guide/modules/#extra-pip-repositories","title":"Extra pip repositories","text":"<p>To add additional pip repositories (probably self-hosted):</p> <pre><code>python {\n    extraIndexUrls = [\"http://extra-url.com\", \"http://extra-url.com\"]\n}\n</code></pre> <p>or with shortcut method (shortcut may be used multiple times):</p> <pre><code>python {\n    extraIndexUrls \"http://extra-url.com\", \"http://extra-url2.com\" \n}\n</code></pre> <p>Extra urls will be applied as --extra-index-url flag for pip commands supporting it: install, download, list and wheel. By default, it only affects <code>pipInstall</code> and <code>pipList</code> tasks. Applied for all <code>BasePipTask</code>, so if you have custom pip tasks, it would be affected too.</p> <p>In case of ssl problems (stale or self-signed certificated), mark domains as trusted:</p> <pre><code>python {\n    trustedHosts = [\"extra-url.com\"]\n}\n</code></pre> <p>or</p> <pre><code>python {\n    trustedHosts \"extra-url.com\"\n}\n</code></pre> <p>Applied as --trusted-host option only for <code>pipInstall</code> (because <code>pip install</code> is the only command supporting this option).</p> <p>Note</p> <p>If, for some reason, you don't want to specify it for all pip tasks, you can configure exact task, for example: <code>pipInstall.extraIndexUrls = [\"http://extra-url.com\", \"http://extra-url2.com\"]</code></p>"},{"location":"guide/modules/#extra-pip-install-options","title":"Extra pip install options","text":"<p>It is impossible to support directly all possible <code>pip install</code> options usages directly with api (safe way), so there is a direct configuration for an additional options. For example:</p> <pre><code>pipInstall.options('--upgrade-strategy', 'only-if-needed')\n</code></pre> <p>Shortcut method above may be called multiple times:</p> <pre><code>pipInstall.options('--a', 'value')\npipInstall.options('--b', 'value')\n</code></pre> <p>Or you can use property directly:</p> <pre><code>pipInstall.options = ['--a', 'value', '--b', 'value']\n</code></pre>"},{"location":"guide/modules/#requirementstxt","title":"Requirements.txt","text":"<p>Plugin supports python requirements.txt file: if file found in project root, it would be loaded automatically.</p> <p>To specify different file location:</p> <pre><code>python.requirements.file = 'path/to/file' // relative to project root\n</code></pre> <p>Tip</p> <p>Requirements file could reference other files with '-r' (<code>-r other-file.txt</code>)</p> <p>To switch off requirements support:</p> <pre><code>python.requirements.use = false\n</code></pre> <p>Note</p> <p>In multi-module projects file is searched relatively to current module. Root module is not searched to avoid situation when root file used in module by mistake.</p> <p>If required, search in root could be configured manually:  <pre><code>python.requirements.file = project.rootProject.rootDir.absolutePath\n</code></pre></p>"},{"location":"guide/modules/#strict-mode","title":"Strict mode","text":"<p>By default, restricted file syntax assumed: </p> <ul> <li>Support exactly the same module types as in gradle declaration:</li> <li>Only strict module version (e.g. <code>foo==1.0</code>)</li> <li>With features support</li> <li>VCS modules with extended syntax (including version)<ul> <li>This syntax might not be parsed correctly by python tools,   but it is required by plugin in order to know installed version (and properly perform up-to-date check).</li> </ul> </li> <li>All referenced files (-r) are also processed (and must comply)</li> <li>All commented or empty lines are skipped</li> </ul> <p>Motivation</p> <p>Allow externalizing pip modules configuration file so python tools could see and parse it, but still restrict version ranges (for reproducible builds). As en example, depndabot could auto update module versions. </p> <p>Example file:</p> <pre><code># simple module (exact version)\nextract-msg == 0.34.3\n\n# features\nrequests[socks,security] == 2.28.1\n\n# vcs syntax (with version part!)\ngit+https://github.com/ictxiangxin/boson/@ea7d9113f71a7eb79083208d4f3bbb74feeb149f#egg=boson-1.4\n</code></pre> <p>In this mode requirements file read by plugin itself and registered in gradle modules (the same as if modules were declared directly in gradle file).</p> <p>Important</p> <p>Module declarations in gradle script override requirements declaration. So if, for example, requirements contains <code>foo==1.1</code> and in gradle script <code>python.pip 'foo:1.0'</code> then version 1.0 would be used.</p> <p>Example reference:</p> <p>Example file:</p> <pre><code># simple module (exact version)\nextract-msg == 0.34.3\n\n# features\nrequests[socks,security] == 2.28.1\n\n# extra deps in other file\n-r prod.txt\n</code></pre>"},{"location":"guide/modules/#native-behaviour","title":"Native behaviour","text":"<p>You can also use requirement file in a native way:</p> <pre><code>python.requirements.strict = false\n</code></pre> <p>In this case instead of manual file parsing plugin will delegate processing to pip:</p> <pre><code>pip -r requirements.txt\n</code></pre> <p>Note</p> <p>Plugin up-to-date check will rely on requirements file last edit time (because plugin not aware of modules inside it). <code>pipUpdates</code> task will not show updates for modules in requirements file (but you could  configure it to show all modules <code>pipUpdates.all = true</code>)</p> <p>If modules also declared in gradle file directly, they would be installed after requirements processing.</p> <p>As an example, this mode might be helpful if you need to rely on python modules, built in gradle's project submodules (in this case python task dependencies must be properly set).</p> <p>See requirements file syntax for all available options</p>"},{"location":"guide/modules/#scope","title":"Scope","text":"<p>Pip dependencies could be installed per project, for current user (~/) or globally.</p> <p>Default behaviour:</p> <ul> <li>if <code>virtualenv</code> module installed (or automatically installed):   manage pip dependencies per project (env <code>.gradle/python</code> created)</li> <li>if no virtualenv - use user scope (<code>--user</code> pip flag):   pip modules are installed only for current user (this avoid permission problems on linux)</li> </ul> <p>To change defaults:</p> <pre><code>python.scope = VIRTUALENV\n</code></pre> <ul> <li><code>GLOBAL</code> - install modules globally (this may not work on linux due to permissions)</li> <li><code>USER</code> - use <code>--user</code> flag to install for current user only</li> <li><code>VIRTUALENV_OR_USER</code> - default</li> <li><code>VIRTUALENV</code> - use <code>virtualenv</code> (if module not installed - error thrown)</li> </ul> <p>Note</p> <p>Values may be declared without quotes because it's an enum which values are declared as project ext properties (<code>ext.USER==ru.vyarus.gradle.plugin.python.PythonExtension.Scope.USER</code>).</p> <p>Complete behaviour matrix see above.</p>"},{"location":"guide/modules/#check-modules-updates","title":"Check modules updates","text":"<p>To quick check if new versions are available for the registered pip modules use <code>pipUpdates</code> task:</p> <pre><code>:pipUpdates\nThe following modules could be updated:\n\n    package            version latest type \n    ------------------ ------- ------ -----\n    click              6.6     6.7    wheel\n</code></pre> <p>Note that it will not show versions for transitive modules, only for modules specified directly in <code>python.pip</code>.</p> <p>To see all available updates (without filtering):</p> <pre><code>pipUpdates.all = true\n</code></pre> <p>Note</p> <p>If you see an error like</p> <pre><code>TypeError: '&gt;' not supported between instances of 'Version' and 'SetuptoolsVersion'\n</code></pre> <p>then update pip:</p> <pre><code>pip install -U pip\n</code></pre>"},{"location":"guide/modules/#cleanup-environment","title":"Cleanup environment","text":"<p>Use <code>cleanPython</code> task to remove current project-specific python environment.</p> <p>This would be required for python version change and for switching to docker (or back). </p>"},{"location":"guide/multimodule/","title":"Multi-module projects","text":"<p>When used in multi-module project, plugin will create virtualenv inside the root project directory in order to share the same environment for all modules.</p> <p>This could be changed with <code>python.envPath</code> configuration in modules.</p>"},{"location":"guide/multimodule/#one-environment-for-all-modules","title":"One environment for all modules","text":"<p>Project with 2 modules (+root):</p> <pre><code>/\n    /mod1/\n    /mod2/\n    build.gradle\n    settings.gradle\n</code></pre> <pre><code>plugins {\n    id 'ru.vyarus.use-python' version '4.1.0' apply false\n}\n\nsubprojects {\n    apply plugin: 'ru.vyarus.use-python'                 \n\n    python {\n        pip 'click:6.7'\n    }\n}\n</code></pre> <p>Python plugin applied for submodules only (not for root project). One virtualenv will be created (at <code>/.gradle/python</code>) and used by both modules.</p> <p>Note that plugins section in root project used for plugin version management.</p>"},{"location":"guide/multimodule/#root-project-use-python-too","title":"Root project use python too","text":"<p>If root project must use python tasks then use allprojects section instead:</p> <pre><code>plugins {\n    id 'ru.vyarus.use-python' version '4.1.0' apply false\n}\n\nallprojects {\n    apply plugin: 'ru.vyarus.use-python'                 \n\n    python {\n        pip 'click:6.7'\n    }\n}\n</code></pre>"},{"location":"guide/multimodule/#environment-in-module-only","title":"Environment in module only","text":"<p>Suppose we want to use python only in one sub module (for example, for docs generation):</p> <pre><code>/\n    /doc/\n    /mod2/\n    build.gradle\n    settings.gradle\n</code></pre> <pre><code>plugins {\n    id 'ru.vyarus.use-python' version '4.1.0' apply false\n}\n\n// this may be inside module's build.gradle                    \nproject(':doc') {\n    apply plugin: 'ru.vyarus.use-python'                 \n\n    python {\n        pip 'click:6.7'\n    }\n}\n</code></pre> <p>Python plugin applied only in docs module, but virtualenv will still be created at the root level. If you want to move virtualenv itself inside module then specify relative path for it: <code>python.envPath = \"python\"</code>.</p>"},{"location":"guide/multimodule/#use-different-virtualenvs-in-modules","title":"Use different virtualenvs in modules","text":"<p>If modules require independent environments (different python versions required or incompatible modules used) then specify relative <code>envPath</code> so environment would be created relative to module dir.</p> <pre><code>/\n    /mod1/\n    /mod2/\n    build.gradle\n    settings.gradle\n</code></pre> <pre><code>plugins {\n    id 'ru.vyarus.use-python' version '4.1.0' apply false\n}\n\nsubprojects {\n    apply plugin: 'ru.vyarus.use-python'                 \n\n    python {\n        envPath = 'python'\n    }\n}\n\n// this may be inside module's build.gradle\nproject(':mod1') {\n    python {\n        pythonPath = \"/path/to/python2\"\n        pip 'click:6.6'\n    }\n}\n\nproject(':mod2') {\n    python {\n        pythonPath = \"/path/to/python3\"\n        pip 'click:6.7'\n    }\n}\n</code></pre> <p>Here <code>mod1</code> will cerate wirtualenv inside <code>/mod1/python</code> from python 2 and <code>mod2</code> will use its own environment created from python 3. </p>"},{"location":"guide/multimodule/#problems-resolution","title":"Problems resolution","text":"<p>Use python commands statistics report could help detect problems (enabled in root module):</p> <pre><code>python.printStats = true \n</code></pre> <p>Report would show all executed commands and mark commands executed in parallel.</p>"},{"location":"guide/plugindev/","title":"Plugins development","text":"<p>Plugin supposed to be used as base for plugins for specific python modules. With it, you don't need to implement modules installation and could use provided abstractions to call python.</p> <p>Example usage: gradle-mkdocs-plugin.</p> <p>In your plugin, add plugin as dependency:</p> <pre><code>dependencies {\n    implementation 'ru.vyarus:gradle-use-python-plugin:4.1.0'\n}\n</code></pre> <p>And apply plugin: <code>project.plugins.apply(PythonPlugin)</code> (required to register <code>python</code> extension and declare default pipInstall task).</p>"},{"location":"guide/plugindev/#extended-task","title":"Extended task","text":"<p>The simplest way is to extend <code>PythonTask</code>:</p> <pre><code>abstract class SomeModuleTask extends PythonTask {\n\n    SomeModuleTask() {\n        // always call specified commands on module\n        module.set('somemodule')\n    }\n\n    @Override\n    List&lt;String&gt; getExtraArgs() {\n        // example of module options configuration with custom extension \n        def res = []\n        SomeModuleExtension ext = project.extensions.getByType(SomeModuleExtension)\n        if (ext.somOption) {\n            res &lt;&lt; '--option'\n        }\n        return res\n    }\n\n    // optionally apply extra behaviour\n    @Override\n    void run() {\n        // before python call               \n        super.run()\n        // after python call\n    }\n}\n</code></pre> <p>Important</p> <p>Task must be abstract because some methods in PythonTask's hierarchy are abstract  (implemented dynamically at runtime by gradle).  </p> <p>If you need to populate some PythonTask property then do it inside your plugin. For example, to configure additional args:</p> <pre><code>SomeModuleExtension extension = project.extensions.getByType(SomeModuleExtension)\n// override default for all your custom tasks\nproject.tasks.withType(SomeModuleTask).configureEach { task -&gt;\n    task.pythonArgs.convention(project.provider {\n        extension.someOption ? ['--option'] : []\n    })\n}\n</code></pre> <p>Usage:</p> <pre><code>pyton.pip 'sommemodule:1'\n\ntasks.register('modCmd', SomeModuleTask) {\n    command = 'module args'\n}\n</code></pre> <p>called: <code>python -m somemodule module arfs --option</code></p>"},{"location":"guide/plugindev/#completely-custom-task","title":"Completely custom task","text":"<p>In some cases, you can use <code>BasePythonTask</code> which is a super class of <code>PythonTask</code> and provides only automatic <code>pythonPath</code> management.</p> <p>Inside this task you can use <code>ru.vyarus.gradle.plugin.python.cmd.Python</code> utility class, directly  to implement all required customactions.</p> <p>Note</p> <p>Using <code>BasePythonTask</code> is required because <code>Python</code> utility requires a subset of gradle <code>Project</code> actions which is implemented with <code>GradleEnvironment</code> (for configuration cache support). You can avoid <code>BasePythonTask</code> (and create environment manually), but it would be simplier to use it, because it would provide you a pre-configured python instance.</p> <p>Example usage:</p> <pre><code>abstract class MyTask extends BasePythonTask {\n\n    @TaskAction\n    void run() {\n        Python python = getPython()\n\n        // execute and get command output\n        String out = python.readOutput(cmd)\n\n        // call module (the same as exec() but applies '-m mod' before command)\n        python.callModule('mod', cmd)\n\n        // direct python call\n        python.exec(cmd)\n    }\n}\n</code></pre> <p>Specific utility for target module could be defined, see <code>ru.vyarus.gradle.plugin.python.cmd.Pip</code> util as an example (simplified):</p> <pre><code>class Pip {\n\n    private final Python python\n\n    Pip(Python python) {\n        this.python = python\n    }\n\n    // declare module specific commands\n\n    void install(String module) {\n        python.callModule('pip', \"install $module\")\n    }\n}\n</code></pre> <p>Important</p> <p><code>Python</code> object use delayed initialization (to avoid putting all parameters inside constructor). By default, initialization will be performed automatically just before python command execution, but this also mean that system binary validation or other errors could happen at that point. It is often required to separate initialization and execution errors and so there is <code>.validate()</code> method triggering initialization (and, as a result, potential initialization errors).</p>"},{"location":"guide/plugindev/#apply-default-modules","title":"Apply default modules","text":"<p>In your plugin you could apply default modules like this:</p> <pre><code>afterEvaluate {\n    PythonExtension ext = project.extensions.getByType(PythonExtension)\n    // delayed default module(s) declaration based on user configuration\n    if (!ext.isModuleDeclared('somemodule')) {\n        ext.pip 'sommemodule:1'\n    }\n}\n</code></pre> <p>Or always declare default modules (before configuration):</p> <pre><code>PythonExtension ext = project.extensions.getByType(PythonExtension)\next.pip 'sommeodule:1', 'othermodule:2'\n</code></pre> <p>User will be able to override default versions by direct module declaration (even downgrade version):</p> <pre><code>python.pip 'sommodule:0.9'\n</code></pre> <p>Note</p> <p>All pip declarations are supported so direct module version could be overridden with VCS declaration and vice-versa (only the declaration order is important).</p>"},{"location":"guide/plugindev/#hide-sensitive-data-in-logged-command","title":"Hide sensitive data in logged command","text":"<p>By default, plugin always logs executed python commands, but sometimes such commands could contain sensitive data (like passwords).</p> <p>For example, pip's --extra-index-url may contain password:</p> <pre><code>--extra-index-url http://user:pass@something.com\n</code></pre> <p>In logged command password should be replaced with *****.</p> <p>To deal with such cases, Python object supports registration of <code>LoggedCommandCleaner</code> object:</p> <pre><code>python.logCommandCleaner(new CleanerInstance)\n</code></pre> <p>As an example see Pip object, which register special cleaner for extra index passwords right in its constructor:</p> <pre><code>Pip(Python python, boolean userScope, boolean useCache) {\n      ...\n\n      // do not show passwords when external indexes used with credentials\n      python.logCommandCleaner { CliUtils.hidePipCredentials(it) }\n  }\n</code></pre> <p>See <code>CliUtils.hidePipCredentials</code> for an implementation example (using regexps). Most likely, implementation would be the same in your case. </p>"},{"location":"guide/plugindev/#docker","title":"Docker","text":"<p>You don't need any additional actions to support docker: python execution will be performed either in docker or on local python, based on task configuration.</p> <p>Note</p> <p>All absolute paths in commands would be replaced automatically to match docker container locations</p> <p>Warning</p> <p>There is no way now to run on windows containers (due to testcontainers restriction), but plugin implements this support for the future. </p>"},{"location":"guide/plugindev/#call-docker-in-task","title":"Call docker in task","text":"<p>In case of docker there might be a need to execute docker command directly. For this, <code>BasePythonTask</code> contains <code>dockerExec</code> method.</p> <p>For example, during development there was a <code>CleanPython</code> task which used it to run deletion inside docker container (later it was replaced by chown calls, but still a good example):</p> <pre><code>@TaskAction\nvoid run() {\n    String path = project.file(getEnvPath()).absolutePath\n    if (dockerUsed) {\n        // with docker, environment would be created with a root user and so it would not be possible\n        // to simply remove folder: so removing within docker\n        String[] cmd = windows ? ['rd', '/s', '/q', \"\\\"$path\\\"\"] : ['rm', '-rf', path]\n        if (dockerExec(cmd) != 0) {\n            throw new GradleException('Python environment cleanup failed')\n        }\n    } else {\n        project.delete(path)\n    }\n}\n</code></pre> <p><code>isDockerUsed()</code>, <code>isWindows()</code> and <code>dockerExec(cmd)</code> are all provided by <code>BasePythonTask</code></p>"},{"location":"guide/plugindev/#chown","title":"Chown","text":"<p>Docker container works with root user and creates all files in mapped project as root. It is ok for windows and mac because then use network volume mappings, but on linux, such files remain as root. As a result, you will not be able to remove them without <code>sudo</code>.</p> <p>In order to workaround this problem, <code>checkPython</code> and <code>pipInstall</code> calls <code>chown</code> on created environment (and after new modules installation) in order to change their permissions (into the same uid and gid as root project dir).</p> <p>If your python tasks create files then you should also call <code>dockerChown(path)</code> manually with local path (inside project). This method will work only on linux host with linux container and if docker enabled.</p> <p>Note</p> <p>Be aware, if you use <code>doLast</code> for it that it will be called only after successful task execution</p>"},{"location":"guide/plugindev/#gradle-environment","title":"Gradle environment","text":"<p>Gradle does not allow you to use <code>Project</code> object directly at runtime. To workaround, it, a special object was added <code>ru.vyarus.gradle.plugin.python.cmd.env.Environment</code> with a subset of required actions:</p> <ul> <li><code>logger</code> - used by python utilities for logging</li> <li><code>rootName</code> - root project name</li> <li><code>projectPath</code> - current project path (like ':mod' or ':' for root project)</li> <li><code>rootDir</code> - path to root project directory</li> <li><code>projectDir</code> - path to project directory (for root project same as rootDir)</li> <li><code>file(path)</code> - same as project.file(path)</li> <li><code>relativePath(path)</code> - same as project.relativePath(path)</li> <li><code>relativeRootPath(path)</code> - produce path, relative for root project (or not change for absolute path)</li> <li><code>exec(...)</code> - almost the same as project.exec(...)</li> </ul> <p>Also object provides project-level and global caches (compatible with configuration cache): * <code>&lt;T&gt; T projectCache(String key, Supplier&lt;T&gt; value)</code>, <code>void updateProjectCache(String key, Object value)</code> * <code>&lt;T&gt; T globalCache(String key, Supplier&lt;T&gt; value)</code>, <code>void updateGlobalCache(String key, Object value)</code></p> <p>And internal debug logging: <code>void debug(String msg)</code>. These logs will only be shown when <code>python.debug = true</code>.</p> <p>There is also a <code>stat</code> method for counting command execution in <code>python.printStats = true</code> report,  but you should not call it manually. <code>Python</code> utility, configured in task, will automatically  record all executions (no additional actions required)</p>"},{"location":"guide/plugindev/#debugging","title":"Debugging","text":"<p>For plugin debugging enable:</p> <pre><code>python {\n    debug = true\n    printStats = true\n}\n</code></pre> <p>Debug option prints all cache operations and additional debug logs (including you logs, if you use environment's debug method). Print stats option is also useful for improper cache usage detection: in case of incorrect cache usage, you'll see many duplicate commands executed.</p>"},{"location":"guide/plugindev/#testing","title":"Testing","text":"<p>In tests you might need to use Python, Pip, Vevnv or, maybe, your own utilities directly in tests. There is a simple <code>SimpleEnvironment</code> object for such cases.</p> <p>For example, create virtual environment in test:</p> <pre><code>Venv env = new Venv(new SimpleEnvironment(testProjectDir), \".python\")\nenv.create(false)\n</code></pre> <p>Note</p> <p><code>testProjectDir</code> is required only if you will need to work with relative paths: in this case, where <code>.python</code> directory would be created.</p> <p>But, if absolute path used, it might be omit: <pre><code>Venv env = new Venv(new SimpleEnvironment(), \"~/.testuserdir\")\n</code></pre></p> <p>Another example, removing global pip package before test:</p> <pre><code>new Pip(new SimpleEnvironment()).uninstall(\"extract-msg\")\n</code></pre>"},{"location":"guide/python/","title":"Python &amp; Pip","text":"<p>Tip</p> <p>Docker might be used instead of direct python installation</p> <p>To make sure python and pip are installed:</p> <pre><code>python --version  \npip --version\n</code></pre> <p>On *nix <code>python</code> usually reference python2. For python3:</p> <pre><code>python3 --version  \npip3 --version\n</code></pre> <p>Tip</p> <p>Python-related configurations</p>"},{"location":"guide/python/#windows-install","title":"Windows install","text":"<p>Download and install python manually or use chocolately:</p> <pre><code>choco install python\n</code></pre> <p>In Windows 10 python 3.9 could be installed from Windows Store: just type 'python' in console and windows will open Windows Store's python page. No additional actions required after installation.</p> <p>Note that windows store python will require minium virtualenv 20.0.11 (or above). (if virtualenv not yet installed then no worry - plugin will install the correct version)</p>"},{"location":"guide/python/#linuxmacos-install","title":"Linux/Macos install","text":"<p>On most *nix distributions python is already installed, but often without pip.</p> <p>Install pip if required (ubuntu example):</p> <pre><code>sudo apt-get install python3-pip\n</code></pre> <p>Make sure the latest pip installed (required to overcome some older pip problems):</p> <pre><code>pip3 install -U pip\n</code></pre> <p>To install exact pip version:</p> <pre><code>pip3 install -U pip==20.0.11\n</code></pre> <p>Note that on ubuntu pip installed with <code>python3-pip</code> package is 9.0.1, but it did not(!) downgrade module versions (e.g. <code>pip install click 6.6</code> when click 6.7 is installed will do nothing). Maybe there are other differences, so it's highly recommended to upgrade pip with <code>pip3 install -U pip</code>.</p> <p>If you need to switch python versions often, you can use pyenv: see this article for ubuntu installation guide. But pay attention to PATH: plugin may not \"see\" pyenv due to different PATH (when not launched from shell).</p>"},{"location":"guide/python/#externally-managed-environment","title":"Externally managed environment","text":"<p>On linux, multiple python packages could be installed. For example:</p> <pre><code>sudo apt install python3.12\n</code></pre> <p>Install python 3.12 accessible with <code>python3.12</code> binary, whereas <code>python3</code> would be a different python (e.g. 3.9)</p> <p>To use such python specify:</p> <pre><code>python {\n    pythonBinary = 'python3.12'\n    breakSystemPackages = true\n}\n</code></pre> <p><code>breakSystemPackages</code> is required if you need to install pip modules and target python does not have virtualenv installed (so plugin would try to install it).</p> <p>Without <code>breakSystemPackages</code> you'll see the following error:</p> <pre><code>error: externally-managed-environment\n\n\u00d7 This environment is externally managed\n\u2570\u2500&gt; To install Python packages system-wide, try apt install\n    python3-xyz, where xyz is the package you are trying to\n    install.\n</code></pre>"},{"location":"guide/python/#possible-pip-issue-warning-linuxmacos","title":"Possible pip issue warning (linux/macos)","text":"<p>If <code>pip3 list -o</code> fails with: <code>TypeError: '&gt;' not supported between instances of 'Version' and 'Version'</code> Then simply update installed pip version: <code>python3 -m pip install --upgrade pip</code></p> <p>This is a known issue related to incorrectly patched pip packages in some distributions.</p>"},{"location":"guide/python/#automatic-pip-upgrade","title":"Automatic pip upgrade","text":"<p>As described above, there are different ways of pip installation in linux and, more important, admin permissions are required to upgrade global pip. So it is impossible to upgrade pip from the plugin (in all cases).</p> <p>But, it is possible inside virtualenv or user (--user) scope. Note that plugin creates virtualenv by default (per project independent python environment).</p> <p>So, in order to use newer pip simply put it as first dependency:</p> <pre><code>python {\n    pip 'pip:10.0.1'\n    pip 'some_module:1.0'\n}\n</code></pre> <p>Here project virtualenv will be created with global pip and newer pip version installed inside environment. Packages installation is sequential, so all other packages will be installed with newer pip (each installation is independent pip command).</p> <p>The same will work for user scope: <code>python.scope = USER</code></p> <p>When applying this trick, consider minimal pip version declared in configuration (<code>python.minPipVersion='9'</code> by default) as minimal pip version required for project setup (instead of minimal version required for work).</p>"},{"location":"guide/python/#automatic-python-install","title":"Automatic python install","text":"<p>Python is assumed to be used as java: install and forget. It perfectly fits user use case: install python once and plugin will replace all manual work on project environment setup.</p> <p>It is also easy to configure python on CI (like travis).</p> <p>If you want automatic python installation, try looking on JetBrain's python-envs plugin. But be careful because it has some caveats (for example, on windows python could be installed automatically just once and requires manual un-installation). </p>"},{"location":"guide/python/#global-python-validation","title":"Global python validation","text":"<p>For global python (when no <code>pythonPath</code> configured) plugin would manually search for python binary in <code>$PATH</code> and would throw error if not found containing  entire <code>$PATH</code>. This is required for cases when PATH visible for gradle process is different to your shell path.</p> <p>For example, on M1 it could be rosetta path instead of native (see this issue).</p> <p>Validation could be disabled with:</p> <pre><code>python.validateSystemBinary = false\n</code></pre> <p>Note</p> <p>This option is ignored if docker support enabled</p>"},{"location":"guide/stats/","title":"Stats","text":"<p>Plugin records all external command executions and could show you report after the build.</p> <p>To enable report:</p> <pre><code>python.printStats = true\n</code></pre> <p>Note</p> <p>Report includes all external commands, including hidden commands, used by plugin for python and other modules detection.</p>"},{"location":"guide/stats/#example","title":"Example","text":"<p>For example, for a sample project like this:</p> <pre><code>python {\n    pip 'extract-msg:0.28.0'\n\n    printStats = true \n}\n\ntasks.register('sample', PythonTask) {\n    command = '-c print(\\'samplee\\')'\n}\n</code></pre> <p>Output would look like this (for <code>sample</code> task execution):</p> <pre><code>Python execution stats:\n\ntask                                        started         duration            \n:checkPython                                18:18:51:117    59ms                python3 --version\n:checkPython                                18:18:51:193    32ms                python3 -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:checkPython                                18:18:51:241    213ms               python3 -m pip --version\n:checkPython                                18:18:51:469    47ms                python3 -m venv -h\n:checkPython                                18:18:51:521    2.34s               python3 -m venv .gradle/python\n:checkPython                                18:18:53:859    9ms                 .gradle/python/bin/python -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:checkPython                                18:18:53:870    217ms               .gradle/python/bin/python -m pip --version\n:pipInstall                                 18:18:54:113    300ms               .gradle/python/bin/python -m pip freeze\n:pipInstall                                 18:18:54:417    3.19s               .gradle/python/bin/python -m pip install extract-msg==0.28.0\n:pipInstall                                 18:18:57:612    289ms               .gradle/python/bin/python -m pip list --format=columns\n:sample                                     18:18:57:905    9ms                 .gradle/python/bin/python -c exec(\"print('samplee')\")\n\n    Executed 11 commands in 6.7s (overall)\n</code></pre>"},{"location":"guide/stats/#failed-tasks","title":"Failed tasks","text":"<p>Failed tasks are also indicated in project.</p> <p>For example, for project:</p> <pre><code>python {               \n    printStats = true\n}\n\ntasks.register('sample', PythonTask) {\n    // ERROR in syntax\n    command = '-c printt(\\'samplee\\')'\n}\n</code></pre> <p>Stats would be:</p> <pre><code>Python execution stats:\n\ntask                                        started         duration            \n:checkPython                                18:22:35:383    50ms                python3 --version\n:checkPython                                18:22:35:445    32ms                python3 -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:sample                                     18:22:35:512    37ms       FAILED   python3 -c exec(\"printt('samplee')\")\n\n    Executed 3 commands in 119ms (overall)\n</code></pre>"},{"location":"guide/stats/#docker","title":"Docker","text":"<p>For docker, executions are also tracked: </p> <pre><code>python {\n    pip 'extract-msg:0.28.0'\n    docker.use = true\n    printStats = true\n}\n\ntasks.register('sample', PythonTask) {\n    command = '-c print(\\'samplee\\')'\n}\n</code></pre> <p>Note that docker container name in shown in report:</p> <pre><code>Python execution stats:\n\ntask                                        started        docker container     duration            \n:checkPython                                18:25:43:159   /cool_noyce          2.08s               python3 --version\n:checkPython                                18:25:45:243   /cool_noyce          33ms                python3 --version\n:checkPython                                18:25:45:288   /cool_noyce          60ms                python3 -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:checkPython                                18:25:45:362   /cool_noyce          1.09s               python3 -m pip --version\n:checkPython                                18:25:46:466   /cool_noyce          106ms               python3 -m venv -h\n:checkPython                                18:25:46:576   /cool_noyce          53ms       FAILED   test -f /usr/local/bin/activate &amp;&amp; echo \"exists\"\n:checkPython                                18:25:46:630   /cool_noyce          2.81s               python3 -m venv .gradle/python\n:checkPython                                18:25:49:443   /cool_noyce          70ms                .gradle/python/bin/python -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:checkPython                                18:25:49:516   /cool_noyce          269ms               .gradle/python/bin/python -m pip --version\n:pipInstall                                 18:25:49:886   /cool_noyce          356ms               .gradle/python/bin/python -m pip freeze\n:pipInstall                                 18:25:50:246   /cool_noyce          6s                  .gradle/python/bin/python -m pip install extract-msg==0.28.0\n:pipInstall                                 18:25:56:316   /cool_noyce          351ms               .gradle/python/bin/python -m pip list --format=columns\n:sample                                     18:25:56:674   /cool_noyce          90ms                .gradle/python/bin/python -c exec(\"print('samplee')\")\n\n    Executed 13 commands in 13.36s (overall)\n</code></pre> <p>Note that report also includes <code>test -f /usr/local/bin/activate &amp;&amp; echo \"exists\"</code> command which is not python execution, but used for file detection inside container (stats show all executions).</p>"},{"location":"guide/stats/#multi-module-projects","title":"Multi-module projects","text":"<p>In multi-module project, report would contain stats for all modules:</p> <pre><code>Python execution stats:\n\ntask                                        started         duration            \n:checkPython                                18:28:43:049    42ms                python3 --version\n:mod12:checkPython                          18:28:43:101    16ms                ../env/bin/python -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:mod12:checkPython                          18:28:43:128    498ms               ../env/bin/python -m pip --version\n:mod12:checkPython                          18:28:43:640    31ms                ../env/bin/python -m venv -h\n:mod12:checkPython                          18:28:43:676    2.23s               ../env/bin/python -m venv ../.gradle/python\n:mod1:checkPython                           18:28:45:908    10ms                ../.gradle/python/bin/python -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:mod12:checkPython                          18:28:45:923    238ms               ../.gradle/python/bin/python -m pip --version\n\n    Executed 7 commands in 3.06s (overall)\n</code></pre> <p>Important</p> <p>In multi-module project, only root module's extension configuration <code>printStats = true</code> would enable stats (simply because stats are global and can't be configured per-project).</p> <p>Or it would be the top-most sub-project applying python plugin.</p>"},{"location":"guide/stats/#duplicates-detection","title":"Duplicates detection","text":"<p>The report also groups duplicate commands automatically.</p> <p>For example, if each sub-module initializes its own virtualenv:</p> <pre><code>subprojects {\n    // NOTE each module has its own virtualenv      \n    python.envPath = 'envx'\n}\n</code></pre> <p>Report would be:</p> <pre><code>Python execution stats:\n\ntask                                        started         duration            \n:checkPython                                19:15:18:011    50ms                python3 --version\n:mod4:checkPython                           19:15:18:074    16ms                ../env/bin/python -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:mod4:checkPython                           19:15:18:103    511ms               ../env/bin/python -m pip --version\n:mod4:checkPython                           19:15:18:629    30ms                ../env/bin/python -m venv -h\n:mod4:checkPython                           19:15:18:664    2.25s               ../env/bin/python -m venv envx\n:checkPython                                19:15:20:912    28ms                python3 -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:mod4:checkPython                        || 19:15:20:943    11ms                envx/bin/python -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:mod3:checkPython                        || 19:15:20:946    2.34s               ../env/bin/python -m venv envx\n:mod4:checkPython                        || 19:15:20:958    243ms               envx/bin/python -m pip --version\n:mod4:pipInstall                         || 19:15:21:215    276ms               envx/bin/python -m pip freeze\n:mod4:pipInstall                         || 19:15:21:495    1.53s               envx/bin/python -m pip install extract-msg==0.28.0\n:mod4:pipInstall                         || 19:15:23:023    306ms               envx/bin/python -m pip list --format=columns\n:mod3:checkPython                        || 19:15:23:285    11ms                envx/bin/python -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:mod1:checkPython                        || 19:15:23:287    2.38s               ../env/bin/python -m venv envx\n:mod3:checkPython                        || 19:15:23:299    241ms               envx/bin/python -m pip --version\n:mod3:pipInstall                         || 19:15:23:547    275ms               envx/bin/python -m pip freeze\n:mod3:pipInstall                         || 19:15:23:824    1.89s               envx/bin/python -m pip install extract-msg==0.28.0\n:mod1:checkPython                        || 19:15:25:666    10ms                envx/bin/python -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:mod2:checkPython                        || 19:15:25:669    2.38s               ../env/bin/python -m venv envx\n:mod1:checkPython                        || 19:15:25:678    244ms               envx/bin/python -m pip --version\n:mod3:pipInstall                         || 19:15:25:712    327ms               envx/bin/python -m pip list --format=columns\n:mod1:pipInstall                         || 19:15:25:929    280ms               envx/bin/python -m pip freeze\n:mod1:pipInstall                         || 19:15:26:211    1.58s               envx/bin/python -m pip install extract-msg==0.28.0\n:mod1:pipInstall                         || 19:15:27:793    308ms               envx/bin/python -m pip list --format=columns\n:mod2:checkPython                        || 19:15:28:054    9ms                 envx/bin/python -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:mod5:checkPython                        || 19:15:28:056    2.38s               ../env/bin/python -m venv envx\n:mod2:checkPython                        || 19:15:28:065    239ms               envx/bin/python -m pip --version\n:mod2:pipInstall                         || 19:15:28:312    268ms               envx/bin/python -m pip freeze\n:mod2:pipInstall                         || 19:15:28:581    1.57s               envx/bin/python -m pip install extract-msg==0.28.0\n:mod2:pipInstall                         || 19:15:30:155    311ms               envx/bin/python -m pip list --format=columns\n:mod5:checkPython                        || 19:15:30:434    9ms                 envx/bin/python -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\")\n:mod5:checkPython                        || 19:15:30:445    224ms               envx/bin/python -m pip --version\n:mod5:pipInstall                            19:15:30:675    268ms               envx/bin/python -m pip freeze\n:mod5:pipInstall                            19:15:30:944    1.56s               envx/bin/python -m pip install extract-msg==0.28.0\n:mod5:pipInstall                            19:15:32:505    300ms               envx/bin/python -m pip list --format=columns\n\n    Executed 35 commands in 24.64s (overall)\n\n    Duplicate executions:\n\n        ../env/bin/python -m venv envx (5)\n            :mod4:checkPython   (work dir: mod4)\n            :mod3:checkPython   (work dir: mod3)\n            :mod1:checkPython   (work dir: mod1)\n            :mod2:checkPython   (work dir: mod2)\n            :mod5:checkPython   (work dir: mod5)\n\n        envx/bin/python -c exec(\"import sys;ver=sys.version_info;print(str(ver.major)+'.'+str(ver.minor)+'.'+str(ver.micro));print(sys.prefix);print(sys.executable)\") (5)\n            :mod4:checkPython   (work dir: mod4)\n            :mod3:checkPython   (work dir: mod3)\n            :mod1:checkPython   (work dir: mod1)\n            :mod2:checkPython   (work dir: mod2)\n            :mod5:checkPython   (work dir: mod5)\n\n        envx/bin/python -m pip --version (5)\n            :mod4:checkPython   (work dir: mod4)\n            :mod3:checkPython   (work dir: mod3)\n            :mod1:checkPython   (work dir: mod1)\n            :mod2:checkPython   (work dir: mod2)\n            :mod5:checkPython   (work dir: mod5)\n\n        envx/bin/python -m pip freeze (5)\n            :mod4:pipInstall   (work dir: mod4)\n            :mod3:pipInstall   (work dir: mod3)\n            :mod1:pipInstall   (work dir: mod1)\n            :mod2:pipInstall   (work dir: mod2)\n            :mod5:pipInstall   (work dir: mod5)\n\n        envx/bin/python -m pip install extract-msg==0.28.0 (5)\n            :mod4:pipInstall   (work dir: mod4)\n            :mod3:pipInstall   (work dir: mod3)\n            :mod1:pipInstall   (work dir: mod1)\n            :mod2:pipInstall   (work dir: mod2)\n            :mod5:pipInstall   (work dir: mod5)\n\n        envx/bin/python -m pip list --format=columns (5)\n            :mod4:pipInstall   (work dir: mod4)\n            :mod3:pipInstall   (work dir: mod3)\n            :mod1:pipInstall   (work dir: mod1)\n            :mod2:pipInstall   (work dir: mod2)\n            :mod5:pipInstall   (work dir: mod5)\n</code></pre> <p>Important</p> <p>Pay attention that report does not count execution context for command: for example <code>envx/bin/python -m pip --version</code> executed multiple times because each module has its own environment, stored at the same directory. So, essentially, it is different commands! </p> <p>Note</p> <p>Note '||' symbol near some commands - it indicates parallel execution with one or more other python commands (this build was started with <code>--parallel</code> flag).</p>"},{"location":"guide/usage/","title":"Call python","text":"<p>Call python command:</p> <pre><code>tasks.register('cmd', PythonTask) {\n    command = \"-c print('sample')\"\n}\n</code></pre> <p>called: <code>python -c print('sample')</code> on win and <code>python -c exec(\"print('sample')\")</code> on *nix (exec applied automatically for compatibility)</p> <p>Call multi-line command:</p> <pre><code>tasks.register('cmd', PythonTask) {\n    command = '-c \"import sys; print(sys.prefix)\"'\n}\n</code></pre> <p>called: <code>python -c \"import sys; print(sys.prefix)\"</code> on win and <code>python -c exec(\"import sys; print(sys.prefix)\")</code> on *nix</p> <p>Note</p> <p>It is important to wrap script with space in quotes (otherwise parser will incorrectly parse arguments).</p> <p>String command is used for simplicity, but it could be array/collection of args:</p> <pre><code>tasks.register('script', PythonTask) { \n    command = ['path/to/script.py', '1', '2'] \n}\n</code></pre>"},{"location":"guide/usage/#pip-module-command","title":"Pip module command","text":"<pre><code>tasks.register('mod', PythonTask) {\n    module = 'sample' \n    command = 'mod args'\n}\n</code></pre> <p>called: <code>python -m sample mod args</code></p>"},{"location":"guide/usage/#script","title":"Script","text":"<pre><code>tasks.register('script', PythonTask) { \n    command = 'path/to/script.py 1 2'\n}\n</code></pre> <p>called: <code>python path/to/script.py 1 2</code> (arguments are optional, just for demo)</p>"},{"location":"guide/usage/#command-parsing","title":"Command parsing","text":"<p>When command passed as string it is manually parsed to arguments array (split by space):</p> <ul> <li>Spaces in quotes are ignored: <code>\"quoted space\"</code> or <code>'quoted space'</code></li> <li>Escaped spaces are ignored: <code>with\\\\ space</code> (argument will be used with simple space then - escape removed).</li> <li>Escaped quotes are ignored: <code>\"with \\\\\"interrnal quotes\\\\\" inside\"</code>. But pay attention that it must be 2 symbols <code>\\\\\"</code> and not <code>\\\"</code> because otherwise it is impossible to detect escape.</li> </ul> <p>To view parsed arguments run gradle with <code>-i</code> flag (enable info logs). In case when command can't be parsed properly (bug in parser or unsupported case) use array of arguments instead of string.</p>"},{"location":"guide/usage/#environment-variables","title":"Environment variables","text":"<p>By default, executed python can access system environment variables (same as <code>System.getenv()</code>).</p> <p>To declare custom (process specific) variables:</p> <pre><code>tasks.register('sample', PythonTask) {\n       command = \"-c \\\"import os;print('variables: '+os.getenv('some', 'null')+' '+os.getenv('foo', 'null'))\\\"\"\n       environment 'some', 1\n       environment 'other', 2\n       environment(['foo': 'bar', 'baz': 'bag'])\n}\n</code></pre> <p>Map based declaration (<code>environment(['foo': 'bar', 'baz': 'bag'])</code>) does not remove previously declared variables (just add all vars from map), but direct assignment <code>environment = ['foo': 'bar', 'baz': 'bag']</code> will reset variables.</p> <p>System variables will be available even after declaring custom variables (of course, custom variables could override global value).</p> <p>Note</p> <p>Environment variable could also be declared in extension to apply for all python commands: <code>python.environment 'some', 1</code> (if environments declared both globally (through extension) and directly on task, they would be merged)</p>"},{"location":"guide/usage/#non-default-python","title":"Non-default python","text":"<p>Python task would use python selected by <code>checkPython</code> task (global or detected virtualenv). If you need to use completely different python for some task, then it should be explicitly stated with <code>useCustomPython</code> property.</p> <p>For example, suppose we use virtual environment, but need to use global python in one task:</p> <pre><code>tasks.register('script', PythonTask) {\n    // global python (it would select python3 automatically on linux)\n    pythonPath = null\n    // force custom python for task\n    useCustomPython = true\n    command = ['path/to/script.py', '1', '2'] \n}\n</code></pre> <p>Additional property (useCustomPython) is required because normally task's <code>pythonPath</code> is ignored (an actual path is selected by <code>checkPython</code> task)</p>"}]}