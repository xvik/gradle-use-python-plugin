{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to gradle use-python plugin \u00b6 Use python in gradle build. The only plugin intention is to simplify python usage from gradle (without managing python itself). Release notes - Compatibility - License Who's using Features \u00b6 Works with directly installed python or docker container (with python) Creates local (project-specific) virtualenv (project-specific python copy) Installs required pip modules (virtualenv by default, but could be global installation) Support requirements.txt file (limited by default) Could be used as basement for building plugins for specific python modules (like mkdocs plugin )","title":"Home"},{"location":"#welcome-to-gradle-use-python-plugin","text":"Use python in gradle build. The only plugin intention is to simplify python usage from gradle (without managing python itself). Release notes - Compatibility - License Who's using","title":"Welcome to gradle use-python plugin"},{"location":"#features","text":"Works with directly installed python or docker container (with python) Creates local (project-specific) virtualenv (project-specific python copy) Installs required pip modules (virtualenv by default, but could be global installation) Support requirements.txt file (limited by default) Could be used as basement for building plugins for specific python modules (like mkdocs plugin )","title":"Features"},{"location":"getting-started/","text":"Getting started \u00b6 Note Plugin does not install python and pip itself and use globally installed python (by default). It's easier to prepare python manually because python have good compatibility (from user perspective) and does not need to be updated often. installation \u00b6 buildscript { repositories { mavenCentral () } dependencies { classpath 'ru.vyarus:gradle-use-python-plugin:3.0.0' } } apply plugin: 'ru.vyarus.use-python' OR plugins { id 'ru.vyarus.use-python' version '3.0.0' } Compatibility matrix Python & Pip \u00b6 Make sure python and pip are installed: python --version pip --version On *nix python usually reference python2. For python3: python3 --version pip3 --version Install python if required. Docker \u00b6 If you have docker installed, you can use python from docker container : python . docker . use = true In this case global python installation is not required. Pip modules \u00b6 If additional pip modules required configure them: python . pip 'module1:1.0' , 'module2:1.0' or python { pip 'module1:1.0' pip 'module2:1.0' } Important Version ranges are not allowed for reproducible builds! (but, eventually, there would be problems in any case because of transitive dependencies) Module features and VCS modules supported. Behaviour \u00b6 Default behaviour: if virtualenv module installed (or automatically installed ): manage pip dependencies per project (env .gradle/python created) if no virtualenv - use user scope ( --user pip flag): pip modules are installed only for current user (this avoid permission problems on linux) To change defaults: python . scope = VIRTUALENV GLOBAL - install modules globally (this may not work on linux due to permissions) USER - use --user flag to install for current user only VIRTUALENV_OR_USER - default VIRTUALENV - use virtualenv (if module not installed - error thrown) Note For multi-module projects, by default, plugin will create virtualenv inside the root project directory in order to share the same environment for all modules (but this could be changed ). Usage \u00b6 Call python command: task cmd ( type: PythonTask ) { command = \"-c print('sample')\" } called: python -c print('sample') on win and python -c exec(\"print('sample')\") on *nix (exec applied automatically for compatibility) Note Each PythonTask would depend on checkPython and pipInstall tasks which would prepare python environment before actual execution. Call multi-line command: task cmd ( type: PythonTask ) { command = \"-c \\\"import sys; print(sys.prefix)\\\"\" } called: python -c \"import sys; print(sys.prefix)\" on win and python -c exec(\"import sys; print(sys.prefix)\") on *nix Note It is important to wrap script with space in quotes (otherwise parser will incorrectly parse arguments). See command parsing specifics and env variables usage String command is used for simplicity, but it could be array/collection of args: task script ( type: PythonTask ) { command = [ 'path/to/script.py' , '1' , '2' ] } Module \u00b6 task mod ( type: PythonTask ) { module = 'sample' command = \"mod args\" } called: python -m sample mod args Script \u00b6 task script ( type: PythonTask ) { command = \"path/to/script.py 1 2\" } called: python path/to/script.py 1 2 (arguments are optional, just for demo)","title":"Getting started"},{"location":"getting-started/#getting-started","text":"Note Plugin does not install python and pip itself and use globally installed python (by default). It's easier to prepare python manually because python have good compatibility (from user perspective) and does not need to be updated often.","title":"Getting started"},{"location":"getting-started/#installation","text":"buildscript { repositories { mavenCentral () } dependencies { classpath 'ru.vyarus:gradle-use-python-plugin:3.0.0' } } apply plugin: 'ru.vyarus.use-python' OR plugins { id 'ru.vyarus.use-python' version '3.0.0' } Compatibility matrix","title":"installation"},{"location":"getting-started/#python-pip","text":"Make sure python and pip are installed: python --version pip --version On *nix python usually reference python2. For python3: python3 --version pip3 --version Install python if required.","title":"Python &amp; Pip"},{"location":"getting-started/#docker","text":"If you have docker installed, you can use python from docker container : python . docker . use = true In this case global python installation is not required.","title":"Docker"},{"location":"getting-started/#pip-modules","text":"If additional pip modules required configure them: python . pip 'module1:1.0' , 'module2:1.0' or python { pip 'module1:1.0' pip 'module2:1.0' } Important Version ranges are not allowed for reproducible builds! (but, eventually, there would be problems in any case because of transitive dependencies) Module features and VCS modules supported.","title":"Pip modules"},{"location":"getting-started/#behaviour","text":"Default behaviour: if virtualenv module installed (or automatically installed ): manage pip dependencies per project (env .gradle/python created) if no virtualenv - use user scope ( --user pip flag): pip modules are installed only for current user (this avoid permission problems on linux) To change defaults: python . scope = VIRTUALENV GLOBAL - install modules globally (this may not work on linux due to permissions) USER - use --user flag to install for current user only VIRTUALENV_OR_USER - default VIRTUALENV - use virtualenv (if module not installed - error thrown) Note For multi-module projects, by default, plugin will create virtualenv inside the root project directory in order to share the same environment for all modules (but this could be changed ).","title":"Behaviour"},{"location":"getting-started/#usage","text":"Call python command: task cmd ( type: PythonTask ) { command = \"-c print('sample')\" } called: python -c print('sample') on win and python -c exec(\"print('sample')\") on *nix (exec applied automatically for compatibility) Note Each PythonTask would depend on checkPython and pipInstall tasks which would prepare python environment before actual execution. Call multi-line command: task cmd ( type: PythonTask ) { command = \"-c \\\"import sys; print(sys.prefix)\\\"\" } called: python -c \"import sys; print(sys.prefix)\" on win and python -c exec(\"import sys; print(sys.prefix)\") on *nix Note It is important to wrap script with space in quotes (otherwise parser will incorrectly parse arguments). See command parsing specifics and env variables usage String command is used for simplicity, but it could be array/collection of args: task script ( type: PythonTask ) { command = [ 'path/to/script.py' , '1' , '2' ] }","title":"Usage"},{"location":"getting-started/#module","text":"task mod ( type: PythonTask ) { module = 'sample' command = \"mod args\" } called: python -m sample mod args","title":"Module"},{"location":"getting-started/#script","text":"task script ( type: PythonTask ) { command = \"path/to/script.py 1 2\" } called: python path/to/script.py 1 2 (arguments are optional, just for demo)","title":"Script"},{"location":"about/compatibility/","text":"Gradle compatibility \u00b6 Plugin compiled for java 8, compatible with java 11. Works with python 2 and 3 (but python 2 not tested anymore) on windows and linux (and macos). Gradle Version 5.3-7 3.0.0 5-5.2 2.3.0 4.x 1.2.0","title":"Compatibility"},{"location":"about/compatibility/#gradle-compatibility","text":"Plugin compiled for java 8, compatible with java 11. Works with python 2 and 3 (but python 2 not tested anymore) on windows and linux (and macos). Gradle Version 5.3-7 3.0.0 5-5.2 2.3.0 4.x 1.2.0","title":"Gradle compatibility"},{"location":"about/history/","text":"3.0.0 (2022-10-22) \u00b6 (breaking) Drop gradle 5.0-5.2 support (minimum required gradle is 5.3) Add docker support (python could be started in docker container without local python) Add dockerChown and dockerExec methods for python tasks for customizations in doFirst or doLast closures Add requirements file support (requirements.txt). By default, requirements support is enabled in strict mode: plugin reads file contents and expects only exact version matches (allows extracting module declarations so external tools could easily parse and update dependencies). In non-strict mode, requirements file processing delegated to pip (no restrictions on declarations) New configuration section: python.requirements Add global python binary validation to reveal PATH problems (might not be the same as user shell PATH) Add validateSystemBinary configuration to be able to disable validation (in case it would not work properly) Add cleanPython task for removing project-specific virtualenv Add python process output to exception message to be sure it will be visible on error (especially on CI) Fix potential memory leak due to gradle Project objects caching (#22) Fix concurrent virtualenv installation in multi-module project with parallel execution enabled (#19) Fix concurrent pipInstall into the same environment with parallel execution 2.3.0 (2021-03-01) \u00b6 Support python installation from Windows Store (#14) Changed virtualenv version installed by default from 16.7.9 to 20.4.2 (because only recent versions could work correctly with python installed from Windows Store) Add minimal required virtualenv check: by default, it's virtualenv 16 (to not fail previously working environments). But it is recommended to use at least 20.0.11 (compatible with Windows Store python). V20 changes pip installation strategy in environment to the same version as bundled with virtualenv instead of always downloading new pip (which increase builds stability). Configured with python.minVirtualenvVersion. Fix up-to-date check in pipInstall task for VCS modules (the latest pip changed freeze output syntax) Hide passwords in logs for pip extra index repository urls with credentials (extraIndexUrls config) (#12) Add general logged command cleaning mechanism to Python object for plugin authors (Pip object uses it for passwords hiding) 2.2.0 (2020-04-06) \u00b6 Add support for pip flags: --trusted-host and --extra-index-url (#10) May be set in python extension or directly for pip tasks ( extraIndexUrls , trustedHosts ). Flags applied only to compatible pip commands. Allow dashes in vcs module name (for example, now it is possible to specify #egg=my-module-11.2 ). NOTE: This may lead to problems with versions also containing dashes (1.1-alpha.1), but it may be easily changed manually (to version without dashes: 1.1.alpha.1) Move python configuration options from PythonTask to BasePythonTask : pythonArgs , environment , workDir , logLevel . Now pip tasks could use these options to fine tune python execution (under pip call). NOTE: extraArgs was not moved because exact tasks (like pipInstall) could perform multiple commands calls and applying args to all of them is not correct (most likely, fail the build). Instead, tasks must implement their own support for additional args. Add free options to pipInstall : pipInstall.options('--upgrade-strategy', 'only-if-needed') . It is not possible to support every possible pip flag with api so this manual customization is required to cover wider range of use-cases. Fix gradle deprecation warnings on some tasks properties (#9) Add environment variables configuration in extension: python.environment 'SAMPLE', 'value' Fix checkPython execution when running from daemon (gradle work dir may differ from project root: confirmed case with gradle 6 on java 11). Use relative path to virtualenv when possible instead of always absolute 2.1.0 (2020-03-17) \u00b6 Add environment variables support (#8): Python object: Python.environment (single and map) Python task: PythonTask.environment (single and map) 2.0.0 (2020-03-13) \u00b6 (breaking) Drop java 7 support (breaking) Drop gradle 4 support Add python.usePipCache option to be able to disable cache for dependencies installation ( --no-cache-dir ) Also, option added to Pip object constructor and BasePipTask (with default from extension) Add Python.getBinaryDir() returning (in most cases) executed python binary folder (based on sys.executable with fallback to sys.prefix/bin ) Fix virtualenv installation fail when \"global\" python is already virtualenv due to --user flag usage (like on travis now) Add Python.isVirtualenv() method. Virtualenv is detected by activate script in python binary (which may not be always accurate, but should work in the majority of cases) Pip internally use Python.isVirtualenv() to prevent applying --user flag Configured ( envPath ) or created virtualenv is validated (shows error on incorrect configuration) Show warnings for cases when virtualenv is created from another virtualenv (because it may have side effects) Add python extra args support (in contrast to extra agrs, applied after command, python args applied before): Add Python.pythonArgs - args applied just after python executable Add PythonTask.pythonArgs Add Virtualenv.python accessor to be able to configure additional arguments Add installed virtualenv version configuration: python.virtualenvVersion . This way, plugin will always install only known to be working version and avoid side effects of \"just released\" versions. By default, 16.7.9 would be installed because 20.0.x has some not fixed regressions Use gradle tasks configuration avoidance for lazy tasks initialization (no init when tasks not needed) 1.2.0 (2018-08-30) \u00b6 Improve virtualenv usage in multi-module project (#5): Fix virtualenv access from module on windows By default virtualenv is created in the root project and used for all modules (breaking) note that before virtualenv was created inside module (on linux) Per module python setup is also possible by overriding envPath 1.1.0 (2018-05-29) \u00b6 Add vcs modules support in format: \"vcs+protocol://repo_url/@vcsVersion#egg=pkg-pkgVersion\" (#2) Support module features syntax: module[feature]:version (#3) PipModule api changes: Added toPipInstallString(): must be used for installation command instead of toPipString() 1.0.2 (2018-04-18) \u00b6 Fix pip 10 compatibility (#1) 1.0.1 (2017-12-26) \u00b6 Fix python command recognition: avoid wrapping for -c module argument Support escaped space and quote during command string parsing Support command definition as array/list in PythonTask 1.0.0 (2017-12-20) \u00b6 Initial release","title":"Release notes"},{"location":"about/history/#300-2022-10-22","text":"(breaking) Drop gradle 5.0-5.2 support (minimum required gradle is 5.3) Add docker support (python could be started in docker container without local python) Add dockerChown and dockerExec methods for python tasks for customizations in doFirst or doLast closures Add requirements file support (requirements.txt). By default, requirements support is enabled in strict mode: plugin reads file contents and expects only exact version matches (allows extracting module declarations so external tools could easily parse and update dependencies). In non-strict mode, requirements file processing delegated to pip (no restrictions on declarations) New configuration section: python.requirements Add global python binary validation to reveal PATH problems (might not be the same as user shell PATH) Add validateSystemBinary configuration to be able to disable validation (in case it would not work properly) Add cleanPython task for removing project-specific virtualenv Add python process output to exception message to be sure it will be visible on error (especially on CI) Fix potential memory leak due to gradle Project objects caching (#22) Fix concurrent virtualenv installation in multi-module project with parallel execution enabled (#19) Fix concurrent pipInstall into the same environment with parallel execution","title":"3.0.0 (2022-10-22)"},{"location":"about/history/#230-2021-03-01","text":"Support python installation from Windows Store (#14) Changed virtualenv version installed by default from 16.7.9 to 20.4.2 (because only recent versions could work correctly with python installed from Windows Store) Add minimal required virtualenv check: by default, it's virtualenv 16 (to not fail previously working environments). But it is recommended to use at least 20.0.11 (compatible with Windows Store python). V20 changes pip installation strategy in environment to the same version as bundled with virtualenv instead of always downloading new pip (which increase builds stability). Configured with python.minVirtualenvVersion. Fix up-to-date check in pipInstall task for VCS modules (the latest pip changed freeze output syntax) Hide passwords in logs for pip extra index repository urls with credentials (extraIndexUrls config) (#12) Add general logged command cleaning mechanism to Python object for plugin authors (Pip object uses it for passwords hiding)","title":"2.3.0 (2021-03-01)"},{"location":"about/history/#220-2020-04-06","text":"Add support for pip flags: --trusted-host and --extra-index-url (#10) May be set in python extension or directly for pip tasks ( extraIndexUrls , trustedHosts ). Flags applied only to compatible pip commands. Allow dashes in vcs module name (for example, now it is possible to specify #egg=my-module-11.2 ). NOTE: This may lead to problems with versions also containing dashes (1.1-alpha.1), but it may be easily changed manually (to version without dashes: 1.1.alpha.1) Move python configuration options from PythonTask to BasePythonTask : pythonArgs , environment , workDir , logLevel . Now pip tasks could use these options to fine tune python execution (under pip call). NOTE: extraArgs was not moved because exact tasks (like pipInstall) could perform multiple commands calls and applying args to all of them is not correct (most likely, fail the build). Instead, tasks must implement their own support for additional args. Add free options to pipInstall : pipInstall.options('--upgrade-strategy', 'only-if-needed') . It is not possible to support every possible pip flag with api so this manual customization is required to cover wider range of use-cases. Fix gradle deprecation warnings on some tasks properties (#9) Add environment variables configuration in extension: python.environment 'SAMPLE', 'value' Fix checkPython execution when running from daemon (gradle work dir may differ from project root: confirmed case with gradle 6 on java 11). Use relative path to virtualenv when possible instead of always absolute","title":"2.2.0 (2020-04-06)"},{"location":"about/history/#210-2020-03-17","text":"Add environment variables support (#8): Python object: Python.environment (single and map) Python task: PythonTask.environment (single and map)","title":"2.1.0 (2020-03-17)"},{"location":"about/history/#200-2020-03-13","text":"(breaking) Drop java 7 support (breaking) Drop gradle 4 support Add python.usePipCache option to be able to disable cache for dependencies installation ( --no-cache-dir ) Also, option added to Pip object constructor and BasePipTask (with default from extension) Add Python.getBinaryDir() returning (in most cases) executed python binary folder (based on sys.executable with fallback to sys.prefix/bin ) Fix virtualenv installation fail when \"global\" python is already virtualenv due to --user flag usage (like on travis now) Add Python.isVirtualenv() method. Virtualenv is detected by activate script in python binary (which may not be always accurate, but should work in the majority of cases) Pip internally use Python.isVirtualenv() to prevent applying --user flag Configured ( envPath ) or created virtualenv is validated (shows error on incorrect configuration) Show warnings for cases when virtualenv is created from another virtualenv (because it may have side effects) Add python extra args support (in contrast to extra agrs, applied after command, python args applied before): Add Python.pythonArgs - args applied just after python executable Add PythonTask.pythonArgs Add Virtualenv.python accessor to be able to configure additional arguments Add installed virtualenv version configuration: python.virtualenvVersion . This way, plugin will always install only known to be working version and avoid side effects of \"just released\" versions. By default, 16.7.9 would be installed because 20.0.x has some not fixed regressions Use gradle tasks configuration avoidance for lazy tasks initialization (no init when tasks not needed)","title":"2.0.0 (2020-03-13)"},{"location":"about/history/#120-2018-08-30","text":"Improve virtualenv usage in multi-module project (#5): Fix virtualenv access from module on windows By default virtualenv is created in the root project and used for all modules (breaking) note that before virtualenv was created inside module (on linux) Per module python setup is also possible by overriding envPath","title":"1.2.0 (2018-08-30)"},{"location":"about/history/#110-2018-05-29","text":"Add vcs modules support in format: \"vcs+protocol://repo_url/@vcsVersion#egg=pkg-pkgVersion\" (#2) Support module features syntax: module[feature]:version (#3) PipModule api changes: Added toPipInstallString(): must be used for installation command instead of toPipString()","title":"1.1.0 (2018-05-29)"},{"location":"about/history/#102-2018-04-18","text":"Fix pip 10 compatibility (#1)","title":"1.0.2 (2018-04-18)"},{"location":"about/history/#101-2017-12-26","text":"Fix python command recognition: avoid wrapping for -c module argument Support escaped space and quote during command string parsing Support command definition as array/list in PythonTask","title":"1.0.1 (2017-12-26)"},{"location":"about/history/#100-2017-12-20","text":"Initial release","title":"1.0.0 (2017-12-20)"},{"location":"about/license/","text":"The MIT License (MIT) Copyright \u00a9 2017-2022, Vyacheslav Rusakov Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"guide/ci/","text":"CI \u00b6 Example configuration, required to use python on CI servers. Warning Docker support will not work on most windows CI servers (like appveyor). Linux CI is completely ok (e.g. works out of the box on github actions) GitHub actions \u00b6 name : CI on : push : pull_request : jobs : build : runs-on : ubuntu-latest name : Java ${{ matrix.java }}, python ${{ matrix.python }} strategy : matrix : java : [ 8 , 11 ] steps : - uses : actions/checkout@v3 - name : Set up JDK ${{ matrix.java }} uses : actions/setup-java@v1 with : java-version : ${{ matrix.java }} - name : Set up Python uses : actions/setup-python@v4 with : python-version : 3.10 - name : Build run : | chmod +x gradlew python --version pip --version ./gradlew assemble --no-daemon - name : Test run : ./gradlew check --no-daemon Appveyour \u00b6 To make plugin work on appveyour you'll need to add python to path: environment : matrix : - JAVA_HOME : C:\\Program Files\\Java\\jdk1.8.0 PYTHON : \"C:\\\\Python36-x64\" install : - set PATH=%PYTHON%;%PYTHON%\\\\Scripts;%PATH% - python --version Now plugin would be able to find python binary. To use python 3.9 you'll need to switch image: image : Visual Studio 2019 See available pythons matrix for more info. Travis \u00b6 To make plugin work on travis you'll need to install python3 packages: language : java dist : bionic jdk : openjdk8 addons : apt : packages : - python3 - python3-pip - python3-setuptools before_install : - python3 --version - pip3 --version - pip3 install -U pip It will be python 3.6 by default (for bionic).","title":"CI"},{"location":"guide/ci/#ci","text":"Example configuration, required to use python on CI servers. Warning Docker support will not work on most windows CI servers (like appveyor). Linux CI is completely ok (e.g. works out of the box on github actions)","title":"CI"},{"location":"guide/ci/#github-actions","text":"name : CI on : push : pull_request : jobs : build : runs-on : ubuntu-latest name : Java ${{ matrix.java }}, python ${{ matrix.python }} strategy : matrix : java : [ 8 , 11 ] steps : - uses : actions/checkout@v3 - name : Set up JDK ${{ matrix.java }} uses : actions/setup-java@v1 with : java-version : ${{ matrix.java }} - name : Set up Python uses : actions/setup-python@v4 with : python-version : 3.10 - name : Build run : | chmod +x gradlew python --version pip --version ./gradlew assemble --no-daemon - name : Test run : ./gradlew check --no-daemon","title":"GitHub actions"},{"location":"guide/ci/#appveyour","text":"To make plugin work on appveyour you'll need to add python to path: environment : matrix : - JAVA_HOME : C:\\Program Files\\Java\\jdk1.8.0 PYTHON : \"C:\\\\Python36-x64\" install : - set PATH=%PYTHON%;%PYTHON%\\\\Scripts;%PATH% - python --version Now plugin would be able to find python binary. To use python 3.9 you'll need to switch image: image : Visual Studio 2019 See available pythons matrix for more info.","title":"Appveyour"},{"location":"guide/ci/#travis","text":"To make plugin work on travis you'll need to install python3 packages: language : java dist : bionic jdk : openjdk8 addons : apt : packages : - python3 - python3-pip - python3-setuptools before_install : - python3 --version - pip3 --version - pip3 install -U pip It will be python 3.6 by default (for bionic).","title":"Travis"},{"location":"guide/configuration/","text":"Configuration \u00b6 Python location \u00b6 On linux, plugin will use python3 if available (and fall back to python if not). To use different binary use: python { pythonBinary = 'python' } This will force python 2 for linux. Also, this may be handy if python binary is named differently. To use non-global python: python { pythonPath = 'path/to/python/binary/' } pythonPath must be set to directory containing python binary (e.g. 'path/to/python/binary/python.exe') Note pythonPath is ignored when virtualenv used (virtualenv located at python.envPath already exists). Important If python can't be found, please pay attention to PATH: most likely, it is different from your shell PATH (for example, this might happen when using pyenv). To check PATH, just put somewhere inside build script: println System . getenv ( 'PATH' ) Minimal python and pip versions \u00b6 To set python version constraint: python { minPythonVersion = '3.2' } Python version format is: major.minor.micro. Constraint may include any number of levels: '3', '3.1', '2.7.5' The same way pip version could be restricted: python { minPipVersion = '9.0.1' } Virtualenv \u00b6 When you declare any pip modules, plugin will try to use virtualenv in order to install required modules locally (for current project only). If virtualenv is not installed - it will be installed automatically in --user scope. If you don't want automatic installation then disable it: python . installVirtualenv = false Plugin installs exact pip version declared in python.virtualenvVersion (by default, 16.7.9). This way, plugin will always install only known to be working version and avoid side effects of \"just released\" versions (note that pip 20 is a major rewrite and may still contain side effects). In any case, plugin checks if virtualenv is already installed and use it to create local environment (if not, then fall back to --user scope by default). Virtualenv usage is driven by declared scope, so if you don't want to use it set: python . scope = USER // or GLOBAL With USER (or GLOBAL) scope, virtualenv will not be used, even if it's already created in project (plugin will ignore it and use global python). If you already use virtualenv in your project (have created manually environment), then simply point plugin to use it: python . envPath = 'path/to/your/env' It will automatically change pythonPath configuration accordingly. Note Plugin will not create environment if you don't use any modules. If you still want to use project specific environment (without declared pip modules) then create it manually: python3 -m virtualenv .gradle/python (default location). Plugin will recognize existing env and use it. Important Virtualenv creates local python copy (by default in .gradle/python ). Copy is created from global python and later used instead of global python. If you want to change used python version in the environment, then manually remove .gradle/python so it could be created again (from global python). To copy environment instead of symlinking (default) set ( --always-copy ): python . envCopy = true Pip \u00b6 By default, all installed python modules are printed to console after pip installations using pip list (of course, if at least one module declared for installation). This should simplify problems resolution (show used transitive dependencies versions). To switch off: python { showInstalledVersions = false } You can always see the list of installed modules with pipList task (exactly the same list as after pipInstall). Note If global python is used with USER scope and some modules were manually installed in global scope then they will not be shown by pipList (and after pip install). To see all modules: pipList . all = true Global modules are hidden by default (for USER scope) because on linux there are a lot of system modules pre-installed. By default, 'pip install' is not called for modules already installed with correct version. In most situations this is preferred behaviour, but if you need to be sure about dependencies then force installation: python { alwaysInstallModules = true } Reference \u00b6 All configuration options with default values: python { // path to python binary (global by default) pythonPath // python binary name (python or python3 by default) pythonBinary // search python in system PATH and fail build if not found (incorrect PATH reveal) validateSystemBinary = true // additional environment variables, visible for all python commands environment = [:] // minimal required python version (m.m.m) minPythonVersion // minimal required pip version (m.m.m) minPipVersion = '9' // show all installed modules versions after pip installation showInstalledVersions = true // always call module install, even if correct version is already installed alwaysInstallModules = false // may be used to disable pip cache (--no-cache-dir option) usePipCache = true // additional pip repositories (--extra-index-url option) extraIndexUrls = [] // trusted hosts for pip install (--trusted-host option) trustedHosts = [] // pip modules installation scope (project local, os user dir, global) scope = VIRTUALENV_OR_USER // automatically install virtualenv module (if pip modules declared and scope allows) installVirtualenv = true // if virtualenv not installed (in --user scope), plugin will install exactly this version // (known to be working version) to avoid side effects virtualenvVersion = '20.4.2' // minimal required virtualenv (v20 is recommended, but by default 16 set to not fail previous // setups) minVirtualenvVersion = '16' // used virtualenv path (if virtualenv used, see 'scope') envPath = '.gradle/python' // copy virtualenv instead of symlink (when created) envCopy = false requirements { // use requirements.txt file use = true // file to use as requirements (path to file) file = 'requirements.txt' // requirements restriction (exact versions, syntax subset support) // false delegates requirements loading to pip strict = true } docker { // enables docker support use = false // image to use image = 'python:3.10.8-alpine3.15' // windows containers indicator (not supported now, done for the future) windows = false // docker ports to expose into host (direct 5000 or mapped '5000:6000') ports = [] } } Note that in case of multi-module project envPath is set to '.gradle/python' inside the root project, even if plugin is activated inside module (see multi-module setup ). PythonTask \u00b6 PythonTask configuration: Property Description pythonPath Path to python binary. By default used path declared in global configuration pythonBinary Python binary name. By default, python3 on linux and python otherwise. validateSystemBinary Search python binary in PATH and fail build to reveal PATH problems workDir Working directory (important if called script/module do file operations). By default, it's a project root createWorkDir Automatically create working directory if does not exist. Enabled by default module Module name to call command on (if command not set module called directly). Useful for derived tasks. command Python command to execute (string, array, iterable) logLevel Logging level for python output. By default is LIFECYCLE (visible in console). To hide output use LogLevel.INFO pythonArgs Extra python arguments applied just after python binary. Useful for declaring common python options (-I, -S, etc.) extraArgs Extra arguments applied at the end of declared command (usually module arguments). Useful for derived tasks to declare default options outputPrefix Prefix, applied for each line of python output. By default is '\\t' to identify output for called gradle command environment Process specific environment variables docker.use Enable docker support docker.image Python image to use docker.windows Windows image use. Not usefule now as testcontainers can't run on windows containers (imlpemented for the future) docker.ports Exposed ports from docker container docker.exclusive Enable exclusive container mode (immediate logs for long-running tasks) Also, task provide extra methods: pythonArgs(String... args) to declare extra python arguments (shortcut to append values to pythonArgs property). extraArgs(String... args) to declare extra arguments (shortcut to append values to extraArgs property). environment(String var, Object value) to set custom environment variable (shortcut to append values to environment property) environment(Map<String, Object> vars) to set multiple custom environment variables at once (shortcut to append values to environment property) docker.ports(Object... ports) to set container ports to expose (direct 5000 or mapped '5000:6000') dockerChown(Object path) to fix root user on paths created inside container for linux dockerExec(Object command) to run native command inside container PipInstallTask \u00b6 Default pip installation task is registered as pipInstall and used to install modules, declared in global configuration. Custom task(s) may be used, if required: task myPipInst ( type: PipInstallTask ) { pip 'mod:1' , 'other:2' } Configuration: Property Description pythonPath Path to python binary. By default used path declared in global configuration pythonBinary Python binary name. By default, python3 on linux and python otherwise. validateSystemBinary Search python binary in PATH and fail build to reveal PATH problems pythonArgs Extra python arguments applied just after python binary. Useful for declaring common python options (-I, -S, etc.) environment Process specific environment variables modules Modules to install. In most cases configured indirectly with pip(..) task methods. By default, modules from global configuration. userScope Use current user scope ( --user flag). Enabled by default to avoid permission problems on *nix (global configuration). showInstalledVersions Perform pip list after installation. By default use global configuration value alwaysInstallModules Call pip install module for all declared modules, even if it is already installed with correct version. By default use global configuration value useCache Can be used to disable pip cache (--no-cache-dir) extraIndexUrls Additional pip repositories (--extra-index-url) trustedHosts / trusted hosts (--trusted-host) options additional pip install options requirements Requirements file to use strictRequirements Strict or native requirements file processing mode And, as shown above, custom methods: pip(String... modules) pip(Iterable<String> modules) options(String... options)","title":"Configuration"},{"location":"guide/configuration/#configuration","text":"","title":"Configuration"},{"location":"guide/configuration/#python-location","text":"On linux, plugin will use python3 if available (and fall back to python if not). To use different binary use: python { pythonBinary = 'python' } This will force python 2 for linux. Also, this may be handy if python binary is named differently. To use non-global python: python { pythonPath = 'path/to/python/binary/' } pythonPath must be set to directory containing python binary (e.g. 'path/to/python/binary/python.exe') Note pythonPath is ignored when virtualenv used (virtualenv located at python.envPath already exists). Important If python can't be found, please pay attention to PATH: most likely, it is different from your shell PATH (for example, this might happen when using pyenv). To check PATH, just put somewhere inside build script: println System . getenv ( 'PATH' )","title":"Python location"},{"location":"guide/configuration/#minimal-python-and-pip-versions","text":"To set python version constraint: python { minPythonVersion = '3.2' } Python version format is: major.minor.micro. Constraint may include any number of levels: '3', '3.1', '2.7.5' The same way pip version could be restricted: python { minPipVersion = '9.0.1' }","title":"Minimal python and pip versions"},{"location":"guide/configuration/#virtualenv","text":"When you declare any pip modules, plugin will try to use virtualenv in order to install required modules locally (for current project only). If virtualenv is not installed - it will be installed automatically in --user scope. If you don't want automatic installation then disable it: python . installVirtualenv = false Plugin installs exact pip version declared in python.virtualenvVersion (by default, 16.7.9). This way, plugin will always install only known to be working version and avoid side effects of \"just released\" versions (note that pip 20 is a major rewrite and may still contain side effects). In any case, plugin checks if virtualenv is already installed and use it to create local environment (if not, then fall back to --user scope by default). Virtualenv usage is driven by declared scope, so if you don't want to use it set: python . scope = USER // or GLOBAL With USER (or GLOBAL) scope, virtualenv will not be used, even if it's already created in project (plugin will ignore it and use global python). If you already use virtualenv in your project (have created manually environment), then simply point plugin to use it: python . envPath = 'path/to/your/env' It will automatically change pythonPath configuration accordingly. Note Plugin will not create environment if you don't use any modules. If you still want to use project specific environment (without declared pip modules) then create it manually: python3 -m virtualenv .gradle/python (default location). Plugin will recognize existing env and use it. Important Virtualenv creates local python copy (by default in .gradle/python ). Copy is created from global python and later used instead of global python. If you want to change used python version in the environment, then manually remove .gradle/python so it could be created again (from global python). To copy environment instead of symlinking (default) set ( --always-copy ): python . envCopy = true","title":"Virtualenv"},{"location":"guide/configuration/#pip","text":"By default, all installed python modules are printed to console after pip installations using pip list (of course, if at least one module declared for installation). This should simplify problems resolution (show used transitive dependencies versions). To switch off: python { showInstalledVersions = false } You can always see the list of installed modules with pipList task (exactly the same list as after pipInstall). Note If global python is used with USER scope and some modules were manually installed in global scope then they will not be shown by pipList (and after pip install). To see all modules: pipList . all = true Global modules are hidden by default (for USER scope) because on linux there are a lot of system modules pre-installed. By default, 'pip install' is not called for modules already installed with correct version. In most situations this is preferred behaviour, but if you need to be sure about dependencies then force installation: python { alwaysInstallModules = true }","title":"Pip"},{"location":"guide/configuration/#reference","text":"All configuration options with default values: python { // path to python binary (global by default) pythonPath // python binary name (python or python3 by default) pythonBinary // search python in system PATH and fail build if not found (incorrect PATH reveal) validateSystemBinary = true // additional environment variables, visible for all python commands environment = [:] // minimal required python version (m.m.m) minPythonVersion // minimal required pip version (m.m.m) minPipVersion = '9' // show all installed modules versions after pip installation showInstalledVersions = true // always call module install, even if correct version is already installed alwaysInstallModules = false // may be used to disable pip cache (--no-cache-dir option) usePipCache = true // additional pip repositories (--extra-index-url option) extraIndexUrls = [] // trusted hosts for pip install (--trusted-host option) trustedHosts = [] // pip modules installation scope (project local, os user dir, global) scope = VIRTUALENV_OR_USER // automatically install virtualenv module (if pip modules declared and scope allows) installVirtualenv = true // if virtualenv not installed (in --user scope), plugin will install exactly this version // (known to be working version) to avoid side effects virtualenvVersion = '20.4.2' // minimal required virtualenv (v20 is recommended, but by default 16 set to not fail previous // setups) minVirtualenvVersion = '16' // used virtualenv path (if virtualenv used, see 'scope') envPath = '.gradle/python' // copy virtualenv instead of symlink (when created) envCopy = false requirements { // use requirements.txt file use = true // file to use as requirements (path to file) file = 'requirements.txt' // requirements restriction (exact versions, syntax subset support) // false delegates requirements loading to pip strict = true } docker { // enables docker support use = false // image to use image = 'python:3.10.8-alpine3.15' // windows containers indicator (not supported now, done for the future) windows = false // docker ports to expose into host (direct 5000 or mapped '5000:6000') ports = [] } } Note that in case of multi-module project envPath is set to '.gradle/python' inside the root project, even if plugin is activated inside module (see multi-module setup ).","title":"Reference"},{"location":"guide/configuration/#pythontask","text":"PythonTask configuration: Property Description pythonPath Path to python binary. By default used path declared in global configuration pythonBinary Python binary name. By default, python3 on linux and python otherwise. validateSystemBinary Search python binary in PATH and fail build to reveal PATH problems workDir Working directory (important if called script/module do file operations). By default, it's a project root createWorkDir Automatically create working directory if does not exist. Enabled by default module Module name to call command on (if command not set module called directly). Useful for derived tasks. command Python command to execute (string, array, iterable) logLevel Logging level for python output. By default is LIFECYCLE (visible in console). To hide output use LogLevel.INFO pythonArgs Extra python arguments applied just after python binary. Useful for declaring common python options (-I, -S, etc.) extraArgs Extra arguments applied at the end of declared command (usually module arguments). Useful for derived tasks to declare default options outputPrefix Prefix, applied for each line of python output. By default is '\\t' to identify output for called gradle command environment Process specific environment variables docker.use Enable docker support docker.image Python image to use docker.windows Windows image use. Not usefule now as testcontainers can't run on windows containers (imlpemented for the future) docker.ports Exposed ports from docker container docker.exclusive Enable exclusive container mode (immediate logs for long-running tasks) Also, task provide extra methods: pythonArgs(String... args) to declare extra python arguments (shortcut to append values to pythonArgs property). extraArgs(String... args) to declare extra arguments (shortcut to append values to extraArgs property). environment(String var, Object value) to set custom environment variable (shortcut to append values to environment property) environment(Map<String, Object> vars) to set multiple custom environment variables at once (shortcut to append values to environment property) docker.ports(Object... ports) to set container ports to expose (direct 5000 or mapped '5000:6000') dockerChown(Object path) to fix root user on paths created inside container for linux dockerExec(Object command) to run native command inside container","title":"PythonTask"},{"location":"guide/configuration/#pipinstalltask","text":"Default pip installation task is registered as pipInstall and used to install modules, declared in global configuration. Custom task(s) may be used, if required: task myPipInst ( type: PipInstallTask ) { pip 'mod:1' , 'other:2' } Configuration: Property Description pythonPath Path to python binary. By default used path declared in global configuration pythonBinary Python binary name. By default, python3 on linux and python otherwise. validateSystemBinary Search python binary in PATH and fail build to reveal PATH problems pythonArgs Extra python arguments applied just after python binary. Useful for declaring common python options (-I, -S, etc.) environment Process specific environment variables modules Modules to install. In most cases configured indirectly with pip(..) task methods. By default, modules from global configuration. userScope Use current user scope ( --user flag). Enabled by default to avoid permission problems on *nix (global configuration). showInstalledVersions Perform pip list after installation. By default use global configuration value alwaysInstallModules Call pip install module for all declared modules, even if it is already installed with correct version. By default use global configuration value useCache Can be used to disable pip cache (--no-cache-dir) extraIndexUrls Additional pip repositories (--extra-index-url) trustedHosts / trusted hosts (--trusted-host) options additional pip install options requirements Requirements file to use strictRequirements Strict or native requirements file processing mode And, as shown above, custom methods: pip(String... modules) pip(Iterable<String> modules) options(String... options)","title":"PipInstallTask"},{"location":"guide/docker/","text":"Docker \u00b6 Instead of direct python usage, plugin could use python inside docker container (docker must be installed). To enable docker support: python . docker . use = true Important Docker support is implemented with testcontainers because testcontainers will always correctly cleanup used containers (extremely important for build failures or \"infinite\" runs). But testcontainers currently only work on linux containers and so you will not be able to use windows python containers . It does not mean it can't be used on windows: it will run on WSL2 (default mode) or Hyper-V (running linux containers on windows). Warning Testcontainers will not work on windows server and so docker support will not work on most windows CI servers (like appveyor). Linux CI is completely ok (e.g. works out of the box on github actions) Image \u00b6 By default, official python docker image used: python:3.10.8-alpine3.15 . But you can change it to any other image containing python: python . docker . image = 'python:3.10.8-alpine3.15' Tip It is highly recommended to always specify exact tags for reproducible builds! Simple image declaration above would lead to docker hub, but if you need to use custom repository simply declare it: registry.mycompany.com/mirror/python:3.10.8-alpine3.15 Behaviour \u00b6 Docker container started before first python call (in checkPython task) and stopped after build completion. Entire project directory is mapped inside container (so python process would be able to access any project file) Working directory would be set to project root It all mentioned in logs: > Task :checkPython [docker] container 'python:3.10.8-alpine3.15' (/focused_wing) started in 1.92s Mount /home/user/projects/project:/usr/src/project Work dir /usr/src/project Note Docker container kept started to speed-up execution (avoid re-starting it for each command), but this also cause python command logs to appear only after execution (current api limitation). This might be a bit confusing for non-immediate tasks like pipInstall , but it's a compromise. Docker containers are stateless (removed after execution) and so, if pip modules used, prefer virtualenv mode (default) because in this case virtualenv would be created inside project \"caching\" all required pip packages. so workflow would be: Docker container started Virtualenv installed into it Virtualenv folder created (inside project) Pip install executed for created python copy On next execution, created environment would be simply used (same as with direct python usage). Note Gradle itself is executed on host and only python commands are executed inside container. Configuration \u00b6 python.docker properties: name Description Default use Enable docker support false image Image name (could be full path with repository) python:3.10.8-alpine3.15 windows Windows container OS. Windows containers support implemented in plugin, but currently not supported by testcontainers false ports Ports to expose from container (for long-lived commands) Note Docker support is experimental and, current configuration is a minimal working configuration. If you have a case requiring more configuration options, please create new issue Docker configuration could be changed globally or per-task. For example: task sample ( type: PythonTask ) { workDir 'src/main' docker . ports 5000 environment 'foo' , 'bar' command = '-c print(\\'samplee\\')' } This changes workDir , docker exposed ports and environment variables. Plugin will detect these changes and will restart container automatically to properly apply configuration (you'll see it in log). Tip To avoid redundant container restarts prefer global docker configuration. But workDir could be set only on task level Task properties affecting container restart (because they could be specified only before container startup): name Description docker.ports container restarts if ports configuration differ (not all required ports exposed) environment container restarts if varaibles change (if more variables used for container start - it's ok) workDir container restarts if work dir changes Note Task also has docker.use option and so docker could be enabled/disabled for exact task, but it will fail if pip modules required Tip All paths used in python commands are processed to represent correct in-container paths. This should simplify usage as no changes required to use task with direct python and inside docker. Also, all path separators changed according to target os (important when running container from windows host). Note Environment variable values are not logged (only keys logged) because they might contain secrets. Exclusive mode \u00b6 There is one configuration option available only for tasks - exclusive mode: task sample ( type: PythonTask ) { docker . exclusive = true module = 'mkdocs' command = 'serve' } In this case new docker container would be started using python command as container command (command keeping container alive). This mode required for infinite or just long tasks because this way logs immediately streamed into gradle console. This is ideal for various dev-servers (like mkdocs dev server in example above). Exclusive task does not stop currently running (shared) container (because other (potential) python tasks may need it). Warning When running infinite task (e.g. dev server) the only way to stop it is using force (usually stop from IDE). After such emergency stop containers may live for about ~10s (keep it in mind), but, eventually, they should be removed. Ports \u00b6 Exposing container ports for host might be useful for long-lived tasks (usually, exclusive tasks, but not necessary). There is a special method for ports configuration in both global extension and tasks: python . docker . ports 5000 , 5010 Ports might be declared as integer and string. In this simple case, ports would be mapped on the same host ports. In order to map port on different host port use colon-syntax: python . docker . ports '5000:5001' , '5010:5011' Here docker port 5000 mapped to host 5001 and 5010 to 5011 Different image \u00b6 Custom task can use a different container image (than declared in global extension) if required (no limits): task sample ( type: PythonTask ) { docker . image = 'python:3.10.7-bullseye' module = 'mkdocs' command = 'serve' } In this case, new container would be started just before python command (and will stay up until gradle finished build). User permissions \u00b6 Docker works as root user and so all files created inside mounted project would be owned by root. On windows and mac volume mounted using network with permissions mapping (no root-owned files on host). But on linux container root permissions would become host root permissions. As a result, you'll need a root rights to simply remove these files (cleanup). In order to fix this situation, plugin will execute chown on created files (with uid and gid of user owning project directory (not current user)). This will work for checkPython and pipInstall tasks. Note As long as uid and gid used instead of user/group name, container does not need to have user with the same uid:gid If your custom python task create other files, then you should fix permissions manually with help of dockerChown method available on all python tasks. You can use doFirst or doLast callbacks. For example, suppose python command creates a file: task sample ( type: PythonTask ) { command = '-c \"with open(\\'build/temp.txt\\', \\'w+\\') as f: pass\"' doLast { dockerChown 'build/temp.txt' } } Without \"chown\" used, next gradlew clean execution would fail. Note doLast is executed only after successful task execution. If you need it to be called in any case you'll have to use gradle graph: gradle . taskGraph . afterTask { task , state -> // execute chown even if task fails if ( task instanceof PythonTask ) { ( task as PythonTask ). dockerChown ( 'some/path' ) } } Important dockerChown will work only for linux container when host is also linux and when docker used, so it is safe to call it without conditions. Also, specified directory (or file) path must exist on local fs (plugin will rewrite path into correct docker path, but first it checks for local existence). Docker commands \u00b6 There is also a way to execute any command inside started docker container with dockerExec method available on all python tasks: task sample ( type: PythonTask ) { doFirst { dockerExec 'ls -l /usr/src/' } command = '-c print(\\'samplee\\')' } Tip As with python commands, docker command could be specified as simple string (will be split by spaces) or as array: ['ls', '-l', '/usr/src/'] (suitable in complex cases when command can't be correctly parsed automatically) Docker command output would be printed in console: [docker] ls -l /usr/src/ total 4 drwx------ 3 1000 1000 4096 Oct 21 08:02 project dockerExec returns command exit code which might be used for conditions: if ( dockerExec (...) == 0 ) { // do something on success } Note When docker not enabled, dockerExec returns -1 and do nothing Concurrency \u00b6 Any number of docker images could be used during the build. Different images would work concurrently. Different tags for the same image would be started as different containers. Execution is synchronized by docker image: in multi-module project or with parallel build only one python command would be executed in container at a time (but commands could run in different containers concurrently). This synchronization applied to minimize potential edge cases (simpler to investigate problems, avoid side effects). Later this could change (based on feedback). Troubleshooting \u00b6 Testcontainers check docker just once \u00b6 Testcontainers remembers not found docker environment error (e.g. docker was simply not started) inside local static variable. But, as docker was executed inside gradle daemon, this state remains, and you can see error: Previous attempts to find a Docker environment failed. Will not retry. Please see logs and check configuration It will continue showing this even if docker already started (it doesn't check at all). To resolve this simply stop gradle daemons: gradlew --stop Pip root user warning \u00b6 As root user used inside container, you'll see the following warning: WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv It's just a warning, but if you want to remove it: python . environment 'PIP_ROOT_USER_ACTION' , 'ignore'","title":"Docker"},{"location":"guide/docker/#docker","text":"Instead of direct python usage, plugin could use python inside docker container (docker must be installed). To enable docker support: python . docker . use = true Important Docker support is implemented with testcontainers because testcontainers will always correctly cleanup used containers (extremely important for build failures or \"infinite\" runs). But testcontainers currently only work on linux containers and so you will not be able to use windows python containers . It does not mean it can't be used on windows: it will run on WSL2 (default mode) or Hyper-V (running linux containers on windows). Warning Testcontainers will not work on windows server and so docker support will not work on most windows CI servers (like appveyor). Linux CI is completely ok (e.g. works out of the box on github actions)","title":"Docker"},{"location":"guide/docker/#image","text":"By default, official python docker image used: python:3.10.8-alpine3.15 . But you can change it to any other image containing python: python . docker . image = 'python:3.10.8-alpine3.15' Tip It is highly recommended to always specify exact tags for reproducible builds! Simple image declaration above would lead to docker hub, but if you need to use custom repository simply declare it: registry.mycompany.com/mirror/python:3.10.8-alpine3.15","title":"Image"},{"location":"guide/docker/#behaviour","text":"Docker container started before first python call (in checkPython task) and stopped after build completion. Entire project directory is mapped inside container (so python process would be able to access any project file) Working directory would be set to project root It all mentioned in logs: > Task :checkPython [docker] container 'python:3.10.8-alpine3.15' (/focused_wing) started in 1.92s Mount /home/user/projects/project:/usr/src/project Work dir /usr/src/project Note Docker container kept started to speed-up execution (avoid re-starting it for each command), but this also cause python command logs to appear only after execution (current api limitation). This might be a bit confusing for non-immediate tasks like pipInstall , but it's a compromise. Docker containers are stateless (removed after execution) and so, if pip modules used, prefer virtualenv mode (default) because in this case virtualenv would be created inside project \"caching\" all required pip packages. so workflow would be: Docker container started Virtualenv installed into it Virtualenv folder created (inside project) Pip install executed for created python copy On next execution, created environment would be simply used (same as with direct python usage). Note Gradle itself is executed on host and only python commands are executed inside container.","title":"Behaviour"},{"location":"guide/docker/#configuration","text":"python.docker properties: name Description Default use Enable docker support false image Image name (could be full path with repository) python:3.10.8-alpine3.15 windows Windows container OS. Windows containers support implemented in plugin, but currently not supported by testcontainers false ports Ports to expose from container (for long-lived commands) Note Docker support is experimental and, current configuration is a minimal working configuration. If you have a case requiring more configuration options, please create new issue Docker configuration could be changed globally or per-task. For example: task sample ( type: PythonTask ) { workDir 'src/main' docker . ports 5000 environment 'foo' , 'bar' command = '-c print(\\'samplee\\')' } This changes workDir , docker exposed ports and environment variables. Plugin will detect these changes and will restart container automatically to properly apply configuration (you'll see it in log). Tip To avoid redundant container restarts prefer global docker configuration. But workDir could be set only on task level Task properties affecting container restart (because they could be specified only before container startup): name Description docker.ports container restarts if ports configuration differ (not all required ports exposed) environment container restarts if varaibles change (if more variables used for container start - it's ok) workDir container restarts if work dir changes Note Task also has docker.use option and so docker could be enabled/disabled for exact task, but it will fail if pip modules required Tip All paths used in python commands are processed to represent correct in-container paths. This should simplify usage as no changes required to use task with direct python and inside docker. Also, all path separators changed according to target os (important when running container from windows host). Note Environment variable values are not logged (only keys logged) because they might contain secrets.","title":"Configuration"},{"location":"guide/docker/#exclusive-mode","text":"There is one configuration option available only for tasks - exclusive mode: task sample ( type: PythonTask ) { docker . exclusive = true module = 'mkdocs' command = 'serve' } In this case new docker container would be started using python command as container command (command keeping container alive). This mode required for infinite or just long tasks because this way logs immediately streamed into gradle console. This is ideal for various dev-servers (like mkdocs dev server in example above). Exclusive task does not stop currently running (shared) container (because other (potential) python tasks may need it). Warning When running infinite task (e.g. dev server) the only way to stop it is using force (usually stop from IDE). After such emergency stop containers may live for about ~10s (keep it in mind), but, eventually, they should be removed.","title":"Exclusive mode"},{"location":"guide/docker/#ports","text":"Exposing container ports for host might be useful for long-lived tasks (usually, exclusive tasks, but not necessary). There is a special method for ports configuration in both global extension and tasks: python . docker . ports 5000 , 5010 Ports might be declared as integer and string. In this simple case, ports would be mapped on the same host ports. In order to map port on different host port use colon-syntax: python . docker . ports '5000:5001' , '5010:5011' Here docker port 5000 mapped to host 5001 and 5010 to 5011","title":"Ports"},{"location":"guide/docker/#different-image","text":"Custom task can use a different container image (than declared in global extension) if required (no limits): task sample ( type: PythonTask ) { docker . image = 'python:3.10.7-bullseye' module = 'mkdocs' command = 'serve' } In this case, new container would be started just before python command (and will stay up until gradle finished build).","title":"Different image"},{"location":"guide/docker/#user-permissions","text":"Docker works as root user and so all files created inside mounted project would be owned by root. On windows and mac volume mounted using network with permissions mapping (no root-owned files on host). But on linux container root permissions would become host root permissions. As a result, you'll need a root rights to simply remove these files (cleanup). In order to fix this situation, plugin will execute chown on created files (with uid and gid of user owning project directory (not current user)). This will work for checkPython and pipInstall tasks. Note As long as uid and gid used instead of user/group name, container does not need to have user with the same uid:gid If your custom python task create other files, then you should fix permissions manually with help of dockerChown method available on all python tasks. You can use doFirst or doLast callbacks. For example, suppose python command creates a file: task sample ( type: PythonTask ) { command = '-c \"with open(\\'build/temp.txt\\', \\'w+\\') as f: pass\"' doLast { dockerChown 'build/temp.txt' } } Without \"chown\" used, next gradlew clean execution would fail. Note doLast is executed only after successful task execution. If you need it to be called in any case you'll have to use gradle graph: gradle . taskGraph . afterTask { task , state -> // execute chown even if task fails if ( task instanceof PythonTask ) { ( task as PythonTask ). dockerChown ( 'some/path' ) } } Important dockerChown will work only for linux container when host is also linux and when docker used, so it is safe to call it without conditions. Also, specified directory (or file) path must exist on local fs (plugin will rewrite path into correct docker path, but first it checks for local existence).","title":"User permissions"},{"location":"guide/docker/#docker-commands","text":"There is also a way to execute any command inside started docker container with dockerExec method available on all python tasks: task sample ( type: PythonTask ) { doFirst { dockerExec 'ls -l /usr/src/' } command = '-c print(\\'samplee\\')' } Tip As with python commands, docker command could be specified as simple string (will be split by spaces) or as array: ['ls', '-l', '/usr/src/'] (suitable in complex cases when command can't be correctly parsed automatically) Docker command output would be printed in console: [docker] ls -l /usr/src/ total 4 drwx------ 3 1000 1000 4096 Oct 21 08:02 project dockerExec returns command exit code which might be used for conditions: if ( dockerExec (...) == 0 ) { // do something on success } Note When docker not enabled, dockerExec returns -1 and do nothing","title":"Docker commands"},{"location":"guide/docker/#concurrency","text":"Any number of docker images could be used during the build. Different images would work concurrently. Different tags for the same image would be started as different containers. Execution is synchronized by docker image: in multi-module project or with parallel build only one python command would be executed in container at a time (but commands could run in different containers concurrently). This synchronization applied to minimize potential edge cases (simpler to investigate problems, avoid side effects). Later this could change (based on feedback).","title":"Concurrency"},{"location":"guide/docker/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"guide/docker/#testcontainers-check-docker-just-once","text":"Testcontainers remembers not found docker environment error (e.g. docker was simply not started) inside local static variable. But, as docker was executed inside gradle daemon, this state remains, and you can see error: Previous attempts to find a Docker environment failed. Will not retry. Please see logs and check configuration It will continue showing this even if docker already started (it doesn't check at all). To resolve this simply stop gradle daemons: gradlew --stop","title":"Testcontainers check docker just once"},{"location":"guide/docker/#pip-root-user-warning","text":"As root user used inside container, you'll see the following warning: WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv It's just a warning, but if you want to remove it: python . environment 'PIP_ROOT_USER_ACTION' , 'ignore'","title":"Pip root user warning"},{"location":"guide/modules/","text":"Pip modules \u00b6 If additional pip modules required: python . pip 'module1:1.0' , 'module2:1.0' or python { pip 'module1:1.0' pip 'module2:1.0' } Module format is: name:version (will mean name==version in pip notion). Non-strict version definition is not allowed (for obvious reasons). Dependencies are installed in declaration order. If duplicate declaration specified then only the latest declaration will be used: python . pip 'module1:2.0' , 'module2:1.0' , 'module1:1.0' Will install version 1.0 of module1 because it was the latest declaration. \"Module overrides\" works for all declaration types (see below): the latest declared module version always wins. Dependencies are installed with pipInstall task which is called before any declared PythonTask . By default, dependencies are installed inside project specific virtualenv (project specific copy of python environment, configured with python.envPath ). Behaviour matrix for possible scope and installVirtualenv configurations: scope installVirtualenv Behaviour default GLOBAL ignored packages installed in global scope ( pip install name ) USER ignored packages installed in user scope ( pip install name --user ) VIRTUALENV_OR_USER true if virtualenv not installed, install it in user scope; create project specific virtualenv and use it default VIRTUALENV_OR_USER false when virtualenv is not installed install packages in user scope (same as USER); when virtualenv installed create project specific virtualenv and use it VIRTUALENV true if virtualenv not installed, install it in user scope; create project specific virtualenv and use it VIRTUALENV false throw error when virtualenv not installed Note that VIRTUALENV + true and VIRTUALENV_OR_USER + true behaviours are the same. Different scope name here describes behavior for unexpected installVirtualenv=false change (to fail or fallback to user scope). USER and GLOBAL scopes will ignore local (virtual)environment, even if project-specific environment was created before, with these options global python will be used instead. Pip module extra features \u00b6 You can declare modules with extra features in module name to install special version of module (with enabled features): python . pip 'requests[socks,security]:2.18.4' Important It is impossible to track if this \"variation\" of module is installed, so plugin performs up-to-date check for such modules by name only (for example, if 'requests==2.18.4' is already installed). For most cases, this is suitable behaviour because, by default, modules are installed in virtualenv and so you will always have correct module installed. For other cases, you can disable up-to-date checks (delegate all dependencies logic to pip): python.alwaysInstallModules = true VCS pip modules \u00b6 You can declare vcs modules : modules installed directly from version control (e.g. git, svn). Format: vcs+protocol://repo_url/@vcsVersion#egg=pkg-pkgVersion @vcsVersion part is required: prefer using commit version or tag for reproducible builds -pkgVersion is installed module version. Required to be able to compare declared plugin with installed version. For example: python . pip 'git+https://github.com/ictxiangxin/boson/@b52727f7170acbedc5a1b4e1df03972bd9bb85e3#egg=boson-0.9' Declares module boson version 0.9 , installed from git commit b52727f7170acbedc5a1b4e1df03972bd9bb85e3 (it may be tag name or branch, but prefer not using branch names). pipInstall will be considered up-to-date if boson==0.9 is already installed. Note that declared module version is completely free: you can set any version (0.10, 1.2, etc.), it is not checked and used only for up-to-date validation. Warning Module version part assumed to follow the last dash, so if you specify version like somethinf-12.0-alpha.1 it would be parsed incorrectly (as package somethinf-12.0 version alpha.1 )! Don't use dashes in version! Vcs module installation is: source checkout and module build (using setup.py). You may need to specify subdirectory as &subdirectory=pkg_dir ( see docs ) To avoid installation problems, package version is not used for actual installation (in spite of the fact that its official convention, it doesn't work in some cases). For example, module above will be installed as (without -0.9 ): pip install git+https://github.com/ictxiangxin/boson/@b52727f7170acbedc5a1b4e1df03972bd9bb85e3#egg = boson All pip supported vcs could be used: git, svn, hg, bzr If up-to-date logic, implemented by pipInstall task, does not suit your needs, you can always disable it with python.alwaysInstallModules = true (pip always called). But this will be slower. Note Since pip 20, compiled vcs module is cached (before it was build on each execution), but it is possible to disable cache (for all modules) with python.usePipCache=false configuration (applies --no-cache-dir pip flag) Extra pip repositories \u00b6 To add additional pip repositories (probably self-hosted): python { extraIndexUrls = [ \"http://extra-url.com\" , \"http://extra-url.com\" ] } or with shortcut method (shortcut may be used multiple times): python { extraIndexUrls \"http://extra-url.com\" , \"http://extra-url2.com\" } Extra urls will be applied as --extra-index-url flag for pip commands supporting it: install, download, list and wheel. By default, it only affects pipInstall and pipList tasks. Applied for all BasePipTask , so if you have custom pip tasks, it would be affected too. In case of ssl problems (stale or self-signed certificated), mark domains as trusted: python { trustedHosts = [ \"extra-url.com\" ] } or python { trustedHosts \"extra-url.com\" } Applied as --trusted-host option only for pipInstall (because pip install is the only command supporting this option). Note If, for some reason, you don't want to specify it for all pip tasks, you can configure exact task, for example: pipInstall.extraIndexUrls = [\"http://extra-url.com\", \"http://extra-url2.com\"] Extra pip install options \u00b6 It is impossible to support directly all possible pip install options usages directly with api (safe way), so there is a direct configuration for an additional options. For example: pipInstall . options ( '--upgrade-strategy' , 'only-if-needed' ) Shortcut method above may be called multiple times: pipInstall . options ( '--a' , 'value' ) pipInstall . options ( '--b' , 'value' ) Or you can use property directly: pipInstall . options = [ '--a' , 'value' , '--b' , 'value' ] Requirements.txt \u00b6 Plugin supports python requirements.txt file: if file found in project root, it would be loaded automatically. To specify different file location: python . requirements . file = 'path/to/file' // relative to project root To switch off requirements support: python . requirements . use = false Note In multi-module projects file is searched relatively to current module. Root module is not searched to avoid situation when root file used in module by mistake. If required, search in root could be configured manually: python . requirements . file = project . rootProject . rootDir . absolutePath Strict mode \u00b6 By default, restricted file syntax assumed: Support exactly the same module types as in gradle declaration: Only strict module version (e.g. foo==1.0 ) With features support VCS modules with extended syntax (including version) This syntax might not be parsed correctly by python tools, but it is required by plugin in order to know installed version (and properly perform up-to-date check). All commented or empty lines are skipped Motivation Allow externalizing pip modules configuration file so python tools could see and parse it, but still restrict version ranges (for reproducible builds). As en example, depndabot could auto update module versions. Example file: # simple module (exact version) extract-msg == 0.34.3 # features requests[socks,security] == 2.28.1 # vcs syntax (with version part!) git+https://github.com/ictxiangxin/boson/@ea7d9113f71a7eb79083208d4f3bbb74feeb149f#egg=boson-1.4 In this mode requirements file read by plugin itself and registered in gradle modules (the same as if modules were declared directly in gradle file). Important Module declarations in gradle script override requirements declaration. So if, for example, requirements contains foo==1.1 and in gradle script python.pip 'foo:1.0' then version 1.0 would be used. Native behaviour \u00b6 You can also use requirement file in a native way : python . requirements . strict = false In this case instead of manual file parsing plugin will delegate processing to pip: pip -r requirements.txt Note Plugin up-to-date check will rely on requirements file last edit time (because plugin not aware of modules inside it). pipUpdates task will not show updates for modules in requirements file (but you could configure it to show all modules pipUpdates.all = true ) If modules also declared in gradle file directly, they would be installed after requirements processing. As an example, this mode might be helpful if you need to rely on python modules, built in gradle's project submodules (in this case python task dependencies must be properly set). See requirements file syntax for all available options Scope \u00b6 Pip dependencies could be installed per project, for current user (~/) or globally. Default behaviour: if virtualenv module installed (or automatically installed ): manage pip dependencies per project (env .gradle/python created) if no virtualenv - use user scope ( --user pip flag): pip modules are installed only for current user (this avoid permission problems on linux) To change defaults: python . scope = VIRTUALENV GLOBAL - install modules globally (this may not work on linux due to permissions) USER - use --user flag to install for current user only VIRTUALENV_OR_USER - default VIRTUALENV - use virtualenv (if module not installed - error thrown) Note Values may be declared without quotes because it's an enum which values are declared as project ext properties ( ext.USER==ru.vyarus.gradle.plugin.python.PythonExtension.Scope.USER ). Complete behaviour matrix see above . Check modules updates \u00b6 To quick check if new versions are available for the registered pip modules use pipUpdates task: :pipUpdates The following modules could be updated: package version latest type ------------------ ------- ------ ----- click 6.6 6.7 wheel Note that it will not show versions for transitive modules, only for modules specified directly in python.pip . To see all available updates (without filtering): pipUpdates . all = true Note If you see an error like TypeError: '>' not supported between instances of 'Version' and 'SetuptoolsVersion' then update pip : pip install -U pip Cleanup environment \u00b6 Use cleanPython task to remove current project-specific python environment. This would be required for python version change and for switching to docker (or back).","title":"Pip modules"},{"location":"guide/modules/#pip-modules","text":"If additional pip modules required: python . pip 'module1:1.0' , 'module2:1.0' or python { pip 'module1:1.0' pip 'module2:1.0' } Module format is: name:version (will mean name==version in pip notion). Non-strict version definition is not allowed (for obvious reasons). Dependencies are installed in declaration order. If duplicate declaration specified then only the latest declaration will be used: python . pip 'module1:2.0' , 'module2:1.0' , 'module1:1.0' Will install version 1.0 of module1 because it was the latest declaration. \"Module overrides\" works for all declaration types (see below): the latest declared module version always wins. Dependencies are installed with pipInstall task which is called before any declared PythonTask . By default, dependencies are installed inside project specific virtualenv (project specific copy of python environment, configured with python.envPath ). Behaviour matrix for possible scope and installVirtualenv configurations: scope installVirtualenv Behaviour default GLOBAL ignored packages installed in global scope ( pip install name ) USER ignored packages installed in user scope ( pip install name --user ) VIRTUALENV_OR_USER true if virtualenv not installed, install it in user scope; create project specific virtualenv and use it default VIRTUALENV_OR_USER false when virtualenv is not installed install packages in user scope (same as USER); when virtualenv installed create project specific virtualenv and use it VIRTUALENV true if virtualenv not installed, install it in user scope; create project specific virtualenv and use it VIRTUALENV false throw error when virtualenv not installed Note that VIRTUALENV + true and VIRTUALENV_OR_USER + true behaviours are the same. Different scope name here describes behavior for unexpected installVirtualenv=false change (to fail or fallback to user scope). USER and GLOBAL scopes will ignore local (virtual)environment, even if project-specific environment was created before, with these options global python will be used instead.","title":"Pip modules"},{"location":"guide/modules/#pip-module-extra-features","text":"You can declare modules with extra features in module name to install special version of module (with enabled features): python . pip 'requests[socks,security]:2.18.4' Important It is impossible to track if this \"variation\" of module is installed, so plugin performs up-to-date check for such modules by name only (for example, if 'requests==2.18.4' is already installed). For most cases, this is suitable behaviour because, by default, modules are installed in virtualenv and so you will always have correct module installed. For other cases, you can disable up-to-date checks (delegate all dependencies logic to pip): python.alwaysInstallModules = true","title":"Pip module extra features"},{"location":"guide/modules/#vcs-pip-modules","text":"You can declare vcs modules : modules installed directly from version control (e.g. git, svn). Format: vcs+protocol://repo_url/@vcsVersion#egg=pkg-pkgVersion @vcsVersion part is required: prefer using commit version or tag for reproducible builds -pkgVersion is installed module version. Required to be able to compare declared plugin with installed version. For example: python . pip 'git+https://github.com/ictxiangxin/boson/@b52727f7170acbedc5a1b4e1df03972bd9bb85e3#egg=boson-0.9' Declares module boson version 0.9 , installed from git commit b52727f7170acbedc5a1b4e1df03972bd9bb85e3 (it may be tag name or branch, but prefer not using branch names). pipInstall will be considered up-to-date if boson==0.9 is already installed. Note that declared module version is completely free: you can set any version (0.10, 1.2, etc.), it is not checked and used only for up-to-date validation. Warning Module version part assumed to follow the last dash, so if you specify version like somethinf-12.0-alpha.1 it would be parsed incorrectly (as package somethinf-12.0 version alpha.1 )! Don't use dashes in version! Vcs module installation is: source checkout and module build (using setup.py). You may need to specify subdirectory as &subdirectory=pkg_dir ( see docs ) To avoid installation problems, package version is not used for actual installation (in spite of the fact that its official convention, it doesn't work in some cases). For example, module above will be installed as (without -0.9 ): pip install git+https://github.com/ictxiangxin/boson/@b52727f7170acbedc5a1b4e1df03972bd9bb85e3#egg = boson All pip supported vcs could be used: git, svn, hg, bzr If up-to-date logic, implemented by pipInstall task, does not suit your needs, you can always disable it with python.alwaysInstallModules = true (pip always called). But this will be slower. Note Since pip 20, compiled vcs module is cached (before it was build on each execution), but it is possible to disable cache (for all modules) with python.usePipCache=false configuration (applies --no-cache-dir pip flag)","title":"VCS pip modules"},{"location":"guide/modules/#extra-pip-repositories","text":"To add additional pip repositories (probably self-hosted): python { extraIndexUrls = [ \"http://extra-url.com\" , \"http://extra-url.com\" ] } or with shortcut method (shortcut may be used multiple times): python { extraIndexUrls \"http://extra-url.com\" , \"http://extra-url2.com\" } Extra urls will be applied as --extra-index-url flag for pip commands supporting it: install, download, list and wheel. By default, it only affects pipInstall and pipList tasks. Applied for all BasePipTask , so if you have custom pip tasks, it would be affected too. In case of ssl problems (stale or self-signed certificated), mark domains as trusted: python { trustedHosts = [ \"extra-url.com\" ] } or python { trustedHosts \"extra-url.com\" } Applied as --trusted-host option only for pipInstall (because pip install is the only command supporting this option). Note If, for some reason, you don't want to specify it for all pip tasks, you can configure exact task, for example: pipInstall.extraIndexUrls = [\"http://extra-url.com\", \"http://extra-url2.com\"]","title":"Extra pip repositories"},{"location":"guide/modules/#extra-pip-install-options","text":"It is impossible to support directly all possible pip install options usages directly with api (safe way), so there is a direct configuration for an additional options. For example: pipInstall . options ( '--upgrade-strategy' , 'only-if-needed' ) Shortcut method above may be called multiple times: pipInstall . options ( '--a' , 'value' ) pipInstall . options ( '--b' , 'value' ) Or you can use property directly: pipInstall . options = [ '--a' , 'value' , '--b' , 'value' ]","title":"Extra pip install options"},{"location":"guide/modules/#requirementstxt","text":"Plugin supports python requirements.txt file: if file found in project root, it would be loaded automatically. To specify different file location: python . requirements . file = 'path/to/file' // relative to project root To switch off requirements support: python . requirements . use = false Note In multi-module projects file is searched relatively to current module. Root module is not searched to avoid situation when root file used in module by mistake. If required, search in root could be configured manually: python . requirements . file = project . rootProject . rootDir . absolutePath","title":"Requirements.txt"},{"location":"guide/modules/#strict-mode","text":"By default, restricted file syntax assumed: Support exactly the same module types as in gradle declaration: Only strict module version (e.g. foo==1.0 ) With features support VCS modules with extended syntax (including version) This syntax might not be parsed correctly by python tools, but it is required by plugin in order to know installed version (and properly perform up-to-date check). All commented or empty lines are skipped Motivation Allow externalizing pip modules configuration file so python tools could see and parse it, but still restrict version ranges (for reproducible builds). As en example, depndabot could auto update module versions. Example file: # simple module (exact version) extract-msg == 0.34.3 # features requests[socks,security] == 2.28.1 # vcs syntax (with version part!) git+https://github.com/ictxiangxin/boson/@ea7d9113f71a7eb79083208d4f3bbb74feeb149f#egg=boson-1.4 In this mode requirements file read by plugin itself and registered in gradle modules (the same as if modules were declared directly in gradle file). Important Module declarations in gradle script override requirements declaration. So if, for example, requirements contains foo==1.1 and in gradle script python.pip 'foo:1.0' then version 1.0 would be used.","title":"Strict mode"},{"location":"guide/modules/#native-behaviour","text":"You can also use requirement file in a native way : python . requirements . strict = false In this case instead of manual file parsing plugin will delegate processing to pip: pip -r requirements.txt Note Plugin up-to-date check will rely on requirements file last edit time (because plugin not aware of modules inside it). pipUpdates task will not show updates for modules in requirements file (but you could configure it to show all modules pipUpdates.all = true ) If modules also declared in gradle file directly, they would be installed after requirements processing. As an example, this mode might be helpful if you need to rely on python modules, built in gradle's project submodules (in this case python task dependencies must be properly set). See requirements file syntax for all available options","title":"Native behaviour"},{"location":"guide/modules/#scope","text":"Pip dependencies could be installed per project, for current user (~/) or globally. Default behaviour: if virtualenv module installed (or automatically installed ): manage pip dependencies per project (env .gradle/python created) if no virtualenv - use user scope ( --user pip flag): pip modules are installed only for current user (this avoid permission problems on linux) To change defaults: python . scope = VIRTUALENV GLOBAL - install modules globally (this may not work on linux due to permissions) USER - use --user flag to install for current user only VIRTUALENV_OR_USER - default VIRTUALENV - use virtualenv (if module not installed - error thrown) Note Values may be declared without quotes because it's an enum which values are declared as project ext properties ( ext.USER==ru.vyarus.gradle.plugin.python.PythonExtension.Scope.USER ). Complete behaviour matrix see above .","title":"Scope"},{"location":"guide/modules/#check-modules-updates","text":"To quick check if new versions are available for the registered pip modules use pipUpdates task: :pipUpdates The following modules could be updated: package version latest type ------------------ ------- ------ ----- click 6.6 6.7 wheel Note that it will not show versions for transitive modules, only for modules specified directly in python.pip . To see all available updates (without filtering): pipUpdates . all = true Note If you see an error like TypeError: '>' not supported between instances of 'Version' and 'SetuptoolsVersion' then update pip : pip install -U pip","title":"Check modules updates"},{"location":"guide/modules/#cleanup-environment","text":"Use cleanPython task to remove current project-specific python environment. This would be required for python version change and for switching to docker (or back).","title":"Cleanup environment"},{"location":"guide/multimodule/","text":"Multi-module projects \u00b6 When used in multi-module project, plugin will create virtualenv inside the root project directory in order to share the same environment for all modules. This could be changed with python.envPath configuration in modules. One environment for all modules \u00b6 Project with 2 modules (+root): / /mod1/ /mod2/ build.gradle settings.gradle plugins { id 'ru.vyarus.use-python' version '3.0.0' apply false } subprojects { apply plugin: 'ru.vyarus.use-python' python { pip 'click:6.7' } } Python plugin applied for submodules only (not for root project). One virtualenv will be created (at /.gradle/python ) and used by both modules. Note that plugins section in root project used for plugin version management. Root project use python too \u00b6 If root project must use python tasks then use allprojects section instead: plugins { id 'ru.vyarus.use-python' version '3.0.0' apply false } allprojects { apply plugin: 'ru.vyarus.use-python' python { pip 'click:6.7' } } Environment in module only \u00b6 Suppose we want to use python only in one sub module (for example, for docs generation): / /doc/ /mod2/ build.gradle settings.gradle plugins { id 'ru.vyarus.use-python' version '3.0.0' apply false } // this may be inside module's build.gradle project ( ':doc' ) { apply plugin: 'ru.vyarus.use-python' python { pip 'click:6.7' } } Python plugin applied only in docs module, but virtualenv will still be created at the root level. If you want to move virtualenv itself inside module then specify relative path for it: python.envPath = \"python\" . Use different virtualenvs in modules \u00b6 If modules require independent environments (different python versions required or incompatible modules used) then specify relative envPath so environment would be created relative to module dir. / /mod1/ /mod2/ build.gradle settings.gradle plugins { id 'ru.vyarus.use-python' version '3.0.0' apply false } subprojects { apply plugin: 'ru.vyarus.use-python' python { envPath = 'python' } } // this may be inside module's build.gradle project ( ':mod1' ) { python { pythonPath = \"/path/to/python2\" pip 'click:6.6' } } project ( ':mod2' ) { python { pythonPath = \"/path/to/python3\" pip 'click:6.7' } } Here mod1 will cerate wirtualenv inside /mod1/python from python 2 and mod2 will use its own environment created from python 3.","title":"Multi-module"},{"location":"guide/multimodule/#multi-module-projects","text":"When used in multi-module project, plugin will create virtualenv inside the root project directory in order to share the same environment for all modules. This could be changed with python.envPath configuration in modules.","title":"Multi-module projects"},{"location":"guide/multimodule/#one-environment-for-all-modules","text":"Project with 2 modules (+root): / /mod1/ /mod2/ build.gradle settings.gradle plugins { id 'ru.vyarus.use-python' version '3.0.0' apply false } subprojects { apply plugin: 'ru.vyarus.use-python' python { pip 'click:6.7' } } Python plugin applied for submodules only (not for root project). One virtualenv will be created (at /.gradle/python ) and used by both modules. Note that plugins section in root project used for plugin version management.","title":"One environment for all modules"},{"location":"guide/multimodule/#root-project-use-python-too","text":"If root project must use python tasks then use allprojects section instead: plugins { id 'ru.vyarus.use-python' version '3.0.0' apply false } allprojects { apply plugin: 'ru.vyarus.use-python' python { pip 'click:6.7' } }","title":"Root project use python too"},{"location":"guide/multimodule/#environment-in-module-only","text":"Suppose we want to use python only in one sub module (for example, for docs generation): / /doc/ /mod2/ build.gradle settings.gradle plugins { id 'ru.vyarus.use-python' version '3.0.0' apply false } // this may be inside module's build.gradle project ( ':doc' ) { apply plugin: 'ru.vyarus.use-python' python { pip 'click:6.7' } } Python plugin applied only in docs module, but virtualenv will still be created at the root level. If you want to move virtualenv itself inside module then specify relative path for it: python.envPath = \"python\" .","title":"Environment in module only"},{"location":"guide/multimodule/#use-different-virtualenvs-in-modules","text":"If modules require independent environments (different python versions required or incompatible modules used) then specify relative envPath so environment would be created relative to module dir. / /mod1/ /mod2/ build.gradle settings.gradle plugins { id 'ru.vyarus.use-python' version '3.0.0' apply false } subprojects { apply plugin: 'ru.vyarus.use-python' python { envPath = 'python' } } // this may be inside module's build.gradle project ( ':mod1' ) { python { pythonPath = \"/path/to/python2\" pip 'click:6.6' } } project ( ':mod2' ) { python { pythonPath = \"/path/to/python3\" pip 'click:6.7' } } Here mod1 will cerate wirtualenv inside /mod1/python from python 2 and mod2 will use its own environment created from python 3.","title":"Use different virtualenvs in modules"},{"location":"guide/plugindev/","text":"Plugins development \u00b6 Plugin supposed to be used as base for plugins for specific python modules. With it, you don't need to implement modules installation and could use provided abstractions to call python. Example usage: gradle-mkdocs-plugin . In your plugin, add plugin as dependency: dependencies { implementation 'ru.vyarus:gradle-use-python-plugin:3.0.0' } And apply plugin: project.plugins.apply(PythonPlugin) (required to register python extension and declare default pipInstall task). Extended task \u00b6 The simplest way is to extend PythonTask : class SomeModuleTask extends PythonTask { @Override String getModule () { // always call specified commands on module return 'somemodule' } @Override List < String > getExtraArgs () { // example of module options configuration with custom extension def res = [] SomeModuleExtension ext = project . extensions . getByType ( SomeModuleExtension ) if ( ext . somOption ) { res << '--option' } return res } // optionally apply extra behaviour @Override void run () { // before python call super . run () // after python call } } Usage: pyton . pip 'sommemodule:1' task modCmd ( type: SomeModuleTask ) { command = 'module args' } called: python -m somemodule module arfs --option In some cases, you can use BasePythonTask which is a super class of PythonTask and provides only automatic pythonPath and pythonBinary properties set from global configuration. Completely custom task \u00b6 Plugin provides ru.vyarus.gradle.plugin.python.cmd.Python utility class, which could be used directly in custom task ( PythonTask is a wrapper above the utility). Example usage: Python python = new Python ( project , getPythonPath (), getPythonBinary ()) . logLevel ( getLogLevel ()) . outputPrefix ( getOutputPrefix ()) . workDir ( getWorkDir ()) . extraArgs ( getExtraArgs ()) // execute and get command output String out = python . readOutput ( cmd ) // call module (the same as exec() but applies '-m mod' before command) python . callModule ( 'mod' , cmd ) // direct python call python . exec ( cmd ) This could be used directly in the completely custom task. Specific utility for target module could be defined, see ru.vyarus.gradle.plugin.python.cmd.Pip util as an example (simplified): class Pip { private final Python python Pip ( Project project , String pythonPath , String binary ) { // configure custom python execution util python = new Python ( project , pythonPath , binary ) . logLevel ( LogLevel . LIFECYCLE ) } // declare module specific commands void install ( String module ) { python . callModule ( 'pip' , \"install $module\" ) } } Important Python object use delayed initialization (to avoid putting all parameters inside constructor). By default, initialization will be performed automatically just before python command execution, but this also mean that system binary validation or other errors could happen at that point. It is often required to separate initialization and execution errors and so there is .validate() method triggering initialization (and, as a result, potential initialization errors). Apply default modules \u00b6 In your plugin you could apply default modules like this: afterEvaluate { PythonExtension ext = project . extensions . getByType ( PythonExtension ) // delayed default module(s) declaration based on user configuration if (! ext . isModuleDeclared ( 'somemodule' )) { ext . pip 'sommemodule:1' } } Or always declare default modules (before configuration): PythonExtension ext = project . extensions . getByType ( PythonExtension ) ext . pip 'sommeodule:1' , 'othermodule:2' User will be able to override default versions by direct module declaration (even downgrade version): python . pip 'sommodule:0.9' Note All pip declarations are supported so direct module version could be overridden with VCS declaration and vice-versa (only the declaration order is important). Hide sensitive data in logged command \u00b6 By default, plugin always logs executed python commands, but sometimes such commands could contain sensitive data (like passwords). For example, pip's --extra-index-url may contain password: --extra-index-url http://user:pass@something.com In logged command password should be replaced with *****. To deal with such cases, Python object supports registration of LoggedCommandCleaner object: python . logCommandCleaner ( new CleanerInstance ) As an example see Pip object, which register special cleaner for extra index passwords right in its constructor: Pip ( Python python , boolean userScope , boolean useCache ) { ... // do not show passwords when external indexes used with credentials python . logCommandCleaner { CliUtils . hidePipCredentials ( it ) } } See CliUtils.hidePipCredentials for an implementation example (using regexps). Most likely, implementation would be the same in your case. Docker \u00b6 You don't need any additional actions to support docker: python execution will be performed either in docker or on local python, based on task configuration. Note All absolute paths in commands would be replaced automatically to match docker container locations Warning There is no way now to run on windows containers (due to testcontainers restriction), but plugin implements this support for the future . Call docker in task \u00b6 In case of docker there might be a need to execute docker command directly. For this, BasePythonTask contains dockerExec method. For example, during development there was a CleanPython task which used it to run deletion inside docker container (later it was replaced by chown calls, but still a good example): @TaskAction void run () { String path = project . file ( getEnvPath ()). absolutePath if ( dockerUsed ) { // with docker, environment would be created with a root user and so it would not be possible // to simply remove folder: so removing within docker String [] cmd = windows ? [ 'rd' , '/s' , '/q' , \"\\\"$path\\\"\" ] : [ 'rm' , '-rf' , path ] if ( dockerExec ( cmd ) != 0 ) { throw new GradleException ( 'Python environment cleanup failed' ) } } else { project . delete ( path ) } } isDockerUsed() , isWindows() and dockerExec(cmd) are all provided by BasePythonTask Chown \u00b6 Docker container works with root user and creates all files in mapped project as root. It is ok for windows and mac because then use network volume mappings, but on linux , such files remain as root . As a result, you will not be able to remove them without sudo . In order to workaround this problem, checkPython and pipInstall calls chown on created environment (and after new modules installation) in order to change their permissions (into the same uid and gid as root project dir). If your python tasks create files then you should also call dockerChown(path) manually with local path (inside project). This method will work only on linux host with linux container and if docker enabled. Note Be aware, if you use doLast for it that it will be called only after successful task execution","title":"Plugin development"},{"location":"guide/plugindev/#plugins-development","text":"Plugin supposed to be used as base for plugins for specific python modules. With it, you don't need to implement modules installation and could use provided abstractions to call python. Example usage: gradle-mkdocs-plugin . In your plugin, add plugin as dependency: dependencies { implementation 'ru.vyarus:gradle-use-python-plugin:3.0.0' } And apply plugin: project.plugins.apply(PythonPlugin) (required to register python extension and declare default pipInstall task).","title":"Plugins development"},{"location":"guide/plugindev/#extended-task","text":"The simplest way is to extend PythonTask : class SomeModuleTask extends PythonTask { @Override String getModule () { // always call specified commands on module return 'somemodule' } @Override List < String > getExtraArgs () { // example of module options configuration with custom extension def res = [] SomeModuleExtension ext = project . extensions . getByType ( SomeModuleExtension ) if ( ext . somOption ) { res << '--option' } return res } // optionally apply extra behaviour @Override void run () { // before python call super . run () // after python call } } Usage: pyton . pip 'sommemodule:1' task modCmd ( type: SomeModuleTask ) { command = 'module args' } called: python -m somemodule module arfs --option In some cases, you can use BasePythonTask which is a super class of PythonTask and provides only automatic pythonPath and pythonBinary properties set from global configuration.","title":"Extended task"},{"location":"guide/plugindev/#completely-custom-task","text":"Plugin provides ru.vyarus.gradle.plugin.python.cmd.Python utility class, which could be used directly in custom task ( PythonTask is a wrapper above the utility). Example usage: Python python = new Python ( project , getPythonPath (), getPythonBinary ()) . logLevel ( getLogLevel ()) . outputPrefix ( getOutputPrefix ()) . workDir ( getWorkDir ()) . extraArgs ( getExtraArgs ()) // execute and get command output String out = python . readOutput ( cmd ) // call module (the same as exec() but applies '-m mod' before command) python . callModule ( 'mod' , cmd ) // direct python call python . exec ( cmd ) This could be used directly in the completely custom task. Specific utility for target module could be defined, see ru.vyarus.gradle.plugin.python.cmd.Pip util as an example (simplified): class Pip { private final Python python Pip ( Project project , String pythonPath , String binary ) { // configure custom python execution util python = new Python ( project , pythonPath , binary ) . logLevel ( LogLevel . LIFECYCLE ) } // declare module specific commands void install ( String module ) { python . callModule ( 'pip' , \"install $module\" ) } } Important Python object use delayed initialization (to avoid putting all parameters inside constructor). By default, initialization will be performed automatically just before python command execution, but this also mean that system binary validation or other errors could happen at that point. It is often required to separate initialization and execution errors and so there is .validate() method triggering initialization (and, as a result, potential initialization errors).","title":"Completely custom task"},{"location":"guide/plugindev/#apply-default-modules","text":"In your plugin you could apply default modules like this: afterEvaluate { PythonExtension ext = project . extensions . getByType ( PythonExtension ) // delayed default module(s) declaration based on user configuration if (! ext . isModuleDeclared ( 'somemodule' )) { ext . pip 'sommemodule:1' } } Or always declare default modules (before configuration): PythonExtension ext = project . extensions . getByType ( PythonExtension ) ext . pip 'sommeodule:1' , 'othermodule:2' User will be able to override default versions by direct module declaration (even downgrade version): python . pip 'sommodule:0.9' Note All pip declarations are supported so direct module version could be overridden with VCS declaration and vice-versa (only the declaration order is important).","title":"Apply default modules"},{"location":"guide/plugindev/#hide-sensitive-data-in-logged-command","text":"By default, plugin always logs executed python commands, but sometimes such commands could contain sensitive data (like passwords). For example, pip's --extra-index-url may contain password: --extra-index-url http://user:pass@something.com In logged command password should be replaced with *****. To deal with such cases, Python object supports registration of LoggedCommandCleaner object: python . logCommandCleaner ( new CleanerInstance ) As an example see Pip object, which register special cleaner for extra index passwords right in its constructor: Pip ( Python python , boolean userScope , boolean useCache ) { ... // do not show passwords when external indexes used with credentials python . logCommandCleaner { CliUtils . hidePipCredentials ( it ) } } See CliUtils.hidePipCredentials for an implementation example (using regexps). Most likely, implementation would be the same in your case.","title":"Hide sensitive data in logged command"},{"location":"guide/plugindev/#docker","text":"You don't need any additional actions to support docker: python execution will be performed either in docker or on local python, based on task configuration. Note All absolute paths in commands would be replaced automatically to match docker container locations Warning There is no way now to run on windows containers (due to testcontainers restriction), but plugin implements this support for the future .","title":"Docker"},{"location":"guide/plugindev/#call-docker-in-task","text":"In case of docker there might be a need to execute docker command directly. For this, BasePythonTask contains dockerExec method. For example, during development there was a CleanPython task which used it to run deletion inside docker container (later it was replaced by chown calls, but still a good example): @TaskAction void run () { String path = project . file ( getEnvPath ()). absolutePath if ( dockerUsed ) { // with docker, environment would be created with a root user and so it would not be possible // to simply remove folder: so removing within docker String [] cmd = windows ? [ 'rd' , '/s' , '/q' , \"\\\"$path\\\"\" ] : [ 'rm' , '-rf' , path ] if ( dockerExec ( cmd ) != 0 ) { throw new GradleException ( 'Python environment cleanup failed' ) } } else { project . delete ( path ) } } isDockerUsed() , isWindows() and dockerExec(cmd) are all provided by BasePythonTask","title":"Call docker in task"},{"location":"guide/plugindev/#chown","text":"Docker container works with root user and creates all files in mapped project as root. It is ok for windows and mac because then use network volume mappings, but on linux , such files remain as root . As a result, you will not be able to remove them without sudo . In order to workaround this problem, checkPython and pipInstall calls chown on created environment (and after new modules installation) in order to change their permissions (into the same uid and gid as root project dir). If your python tasks create files then you should also call dockerChown(path) manually with local path (inside project). This method will work only on linux host with linux container and if docker enabled. Note Be aware, if you use doLast for it that it will be called only after successful task execution","title":"Chown"},{"location":"guide/python/","text":"Python & Pip \u00b6 Tip Docker might be used instead of direct python installation To make sure python and pip are installed: python --version pip --version On *nix python usually reference python2. For python3: python3 --version pip3 --version Tip Python-related configurations Windows install \u00b6 Download and install python manually or use chocolately : choco install python In Windows 10 python 3.9 could be installed from Windows Store: just type 'python' in console and windows will open Windows Store's python page. No additional actions required after installation. Note that windows store python will require minium virtualenv 20.0.11 (or above). (if virtualenv not yet installed then no worry - plugin will install the correct version) Linux/Macos install \u00b6 On most *nix distributions python is already installed, but often without pip. Install pip if required (ubuntu example): sudo apt-get install python3-pip Make sure the latest pip installed (required to overcome some older pip problems): pip3 install -U pip To install exact pip version: pip3 install -U pip == 20 .0.11 Note that on ubuntu pip installed with python3-pip package is 9.0.1, but it did not(!) downgrade module versions (e.g. pip install click 6.6 when click 6.7 is installed will do nothing). Maybe there are other differences, so it's highly recommended to upgrade pip with pip3 install -U pip . If you need to switch python versions often, you can use pyenv : see this article for ubuntu installation guide. But pay attention to PATH: plugin may not \"see\" pyenv due to different PATH (when not launched from shell). Possible pip issue warning (linux/macos) \u00b6 If pip3 list -o fails with: TypeError: '>' not supported between instances of 'Version' and 'Version' Then simply update installed pip version: python3 -m pip install --upgrade pip This is a known issue related to incorrectly patched pip packages in some distributions. Automatic pip upgrade \u00b6 As described above, there are different ways of pip installation in linux and, more important, admin permissions are required to upgrade global pip. So it is impossible to upgrade pip from the plugin (in all cases). But, it is possible inside virtualenv or user (--user) scope. Note that plugin creates virtualenv by default (per project independent python environment). So, in order to use newer pip simply put it as first dependency: python { pip 'pip:10.0.1' pip 'some_module:1.0' } Here project virtualenv will be created with global pip and newer pip version installed inside environment. Packages installation is sequential, so all other packages will be installed with newer pip (each installation is independent pip command). The same will work for user scope: python.scope = USER When applying this trick, consider minimal pip version declared in configuration ( python.minPipVersion='9' by default) as minimal pip version required for project setup (instead of minimal version required for work ). Automatic python install \u00b6 Python is assumed to be used as java: install and forget. It perfectly fits user use case: install python once and plugin will replace all manual work on project environment setup. It is also easy to configure python on CI (like travis). If you want automatic python installation, try looking on JetBrain's python-envs plugin . But be careful because it has some caveats (for example, on windows python could be installed automatically just once and requires manual un-installation). Global python validation \u00b6 For global python (when no pythonPath configured) plugin would manually search for python binary in $PATH and would throw error if not found containing entire $PATH . This is required for cases when PATH visible for gradle process is different to your shell path. For example, on M1 it could be rosetta path instead of native (see this issue ). Validation could be disabled with: python . validateSystemBinary = false Note This option is ignored if docker support enabled","title":"Python install"},{"location":"guide/python/#python-pip","text":"Tip Docker might be used instead of direct python installation To make sure python and pip are installed: python --version pip --version On *nix python usually reference python2. For python3: python3 --version pip3 --version Tip Python-related configurations","title":"Python &amp; Pip"},{"location":"guide/python/#windows-install","text":"Download and install python manually or use chocolately : choco install python In Windows 10 python 3.9 could be installed from Windows Store: just type 'python' in console and windows will open Windows Store's python page. No additional actions required after installation. Note that windows store python will require minium virtualenv 20.0.11 (or above). (if virtualenv not yet installed then no worry - plugin will install the correct version)","title":"Windows install"},{"location":"guide/python/#linuxmacos-install","text":"On most *nix distributions python is already installed, but often without pip. Install pip if required (ubuntu example): sudo apt-get install python3-pip Make sure the latest pip installed (required to overcome some older pip problems): pip3 install -U pip To install exact pip version: pip3 install -U pip == 20 .0.11 Note that on ubuntu pip installed with python3-pip package is 9.0.1, but it did not(!) downgrade module versions (e.g. pip install click 6.6 when click 6.7 is installed will do nothing). Maybe there are other differences, so it's highly recommended to upgrade pip with pip3 install -U pip . If you need to switch python versions often, you can use pyenv : see this article for ubuntu installation guide. But pay attention to PATH: plugin may not \"see\" pyenv due to different PATH (when not launched from shell).","title":"Linux/Macos install"},{"location":"guide/python/#possible-pip-issue-warning-linuxmacos","text":"If pip3 list -o fails with: TypeError: '>' not supported between instances of 'Version' and 'Version' Then simply update installed pip version: python3 -m pip install --upgrade pip This is a known issue related to incorrectly patched pip packages in some distributions.","title":"Possible pip issue warning (linux/macos)"},{"location":"guide/python/#automatic-pip-upgrade","text":"As described above, there are different ways of pip installation in linux and, more important, admin permissions are required to upgrade global pip. So it is impossible to upgrade pip from the plugin (in all cases). But, it is possible inside virtualenv or user (--user) scope. Note that plugin creates virtualenv by default (per project independent python environment). So, in order to use newer pip simply put it as first dependency: python { pip 'pip:10.0.1' pip 'some_module:1.0' } Here project virtualenv will be created with global pip and newer pip version installed inside environment. Packages installation is sequential, so all other packages will be installed with newer pip (each installation is independent pip command). The same will work for user scope: python.scope = USER When applying this trick, consider minimal pip version declared in configuration ( python.minPipVersion='9' by default) as minimal pip version required for project setup (instead of minimal version required for work ).","title":"Automatic pip upgrade"},{"location":"guide/python/#automatic-python-install","text":"Python is assumed to be used as java: install and forget. It perfectly fits user use case: install python once and plugin will replace all manual work on project environment setup. It is also easy to configure python on CI (like travis). If you want automatic python installation, try looking on JetBrain's python-envs plugin . But be careful because it has some caveats (for example, on windows python could be installed automatically just once and requires manual un-installation).","title":"Automatic python install"},{"location":"guide/python/#global-python-validation","text":"For global python (when no pythonPath configured) plugin would manually search for python binary in $PATH and would throw error if not found containing entire $PATH . This is required for cases when PATH visible for gradle process is different to your shell path. For example, on M1 it could be rosetta path instead of native (see this issue ). Validation could be disabled with: python . validateSystemBinary = false Note This option is ignored if docker support enabled","title":"Global python validation"},{"location":"guide/usage/","text":"Call python \u00b6 Call python command: task cmd ( type: PythonTask ) { command = \"-c print('sample')\" } called: python -c print('sample') on win and python -c exec(\"print('sample')\") on *nix (exec applied automatically for compatibility) Call multi-line command: task cmd ( type: PythonTask ) { command = \"-c \\\"import sys; print(sys.prefix)\\\"\" } called: python -c \"import sys; print(sys.prefix)\" on win and python -c exec(\"import sys; print(sys.prefix)\") on *nix Note It is important to wrap script with space in quotes (otherwise parser will incorrectly parse arguments). String command is used for simplicity, but it could be array/collection of args: task script ( type: PythonTask ) { command = [ 'path/to/script.py' , '1' , '2' ] } Pip module command \u00b6 task mod ( type: PythonTask ) { module = 'sample' command = \"mod args\" } called: python -m sample mod args Script \u00b6 task script ( type: PythonTask ) { command = \"path/to/script.py 1 2\" } called: python path/to/script.py 1 2 (arguments are optional, just for demo) Command parsing \u00b6 When command passed as string it is manually parsed to arguments array (split by space): Spaces in quotes are ignored: \"quoted space\" or 'quoted space' Escaped spaces are ignored: with\\\\ space (argument will be used with simple space then - escape removed). Escaped quotes are ignored: \"with \\\\\"interrnal quotes\\\\\" inside\" . But pay attention that it must be 2 symbols \\\\\" and not \\\" because otherwise it is impossible to detect escape. To view parsed arguments run gradle with -i flag (enable info logs). In case when command can't be parsed properly (bug in parser or unsupported case) use array of arguments instead of string. Environment variables \u00b6 By default, executed python can access system environment variables (same as System.getenv() ). To declare custom (process specific) variables: task sample ( type: PythonTask ) { command = \"-c \\\"import os;print('variables: '+os.getenv('some', 'null')+' '+os.getenv('foo', 'null'))\\\"\" environment 'some' , 1 environment 'other' , 2 environment ([ 'foo' : 'bar' , 'baz' : 'bag' ]) } Map based declaration ( environment(['foo': 'bar', 'baz': 'bag']) ) does not remove previously declared variables (just add all vars from map), but direct assignment environment = ['foo': 'bar', 'baz': 'bag'] will reset variables. System variables will be available even after declaring custom variables (of course, custom variables could override global value). Note Environment variable could also be declared in extension to apply for all python commands: python.environment 'some', 1 (if environments declared both globally (through extension) and directly on task, they would be merged)","title":"Usage"},{"location":"guide/usage/#call-python","text":"Call python command: task cmd ( type: PythonTask ) { command = \"-c print('sample')\" } called: python -c print('sample') on win and python -c exec(\"print('sample')\") on *nix (exec applied automatically for compatibility) Call multi-line command: task cmd ( type: PythonTask ) { command = \"-c \\\"import sys; print(sys.prefix)\\\"\" } called: python -c \"import sys; print(sys.prefix)\" on win and python -c exec(\"import sys; print(sys.prefix)\") on *nix Note It is important to wrap script with space in quotes (otherwise parser will incorrectly parse arguments). String command is used for simplicity, but it could be array/collection of args: task script ( type: PythonTask ) { command = [ 'path/to/script.py' , '1' , '2' ] }","title":"Call python"},{"location":"guide/usage/#pip-module-command","text":"task mod ( type: PythonTask ) { module = 'sample' command = \"mod args\" } called: python -m sample mod args","title":"Pip module command"},{"location":"guide/usage/#script","text":"task script ( type: PythonTask ) { command = \"path/to/script.py 1 2\" } called: python path/to/script.py 1 2 (arguments are optional, just for demo)","title":"Script"},{"location":"guide/usage/#command-parsing","text":"When command passed as string it is manually parsed to arguments array (split by space): Spaces in quotes are ignored: \"quoted space\" or 'quoted space' Escaped spaces are ignored: with\\\\ space (argument will be used with simple space then - escape removed). Escaped quotes are ignored: \"with \\\\\"interrnal quotes\\\\\" inside\" . But pay attention that it must be 2 symbols \\\\\" and not \\\" because otherwise it is impossible to detect escape. To view parsed arguments run gradle with -i flag (enable info logs). In case when command can't be parsed properly (bug in parser or unsupported case) use array of arguments instead of string.","title":"Command parsing"},{"location":"guide/usage/#environment-variables","text":"By default, executed python can access system environment variables (same as System.getenv() ). To declare custom (process specific) variables: task sample ( type: PythonTask ) { command = \"-c \\\"import os;print('variables: '+os.getenv('some', 'null')+' '+os.getenv('foo', 'null'))\\\"\" environment 'some' , 1 environment 'other' , 2 environment ([ 'foo' : 'bar' , 'baz' : 'bag' ]) } Map based declaration ( environment(['foo': 'bar', 'baz': 'bag']) ) does not remove previously declared variables (just add all vars from map), but direct assignment environment = ['foo': 'bar', 'baz': 'bag'] will reset variables. System variables will be available even after declaring custom variables (of course, custom variables could override global value). Note Environment variable could also be declared in extension to apply for all python commands: python.environment 'some', 1 (if environments declared both globally (through extension) and directly on task, they would be merged)","title":"Environment variables"}]}